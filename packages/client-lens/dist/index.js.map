{"version":3,"sources":["../src/index.ts","../../../node_modules/viem/node_modules/@noble/hashes/src/_md.ts","../../../node_modules/viem/node_modules/@noble/hashes/src/sha256.ts","../../../node_modules/viem/accounts/toAccount.ts","../../../node_modules/viem/accounts/utils/publicKeyToAddress.ts","../../../node_modules/viem/utils/signature/serializeSignature.ts","../../../node_modules/viem/accounts/utils/sign.ts","../../../node_modules/viem/utils/encoding/toRlp.ts","../../../node_modules/viem/experimental/eip7702/utils/hashAuthorization.ts","../../../node_modules/viem/accounts/utils/signAuthorization.ts","../../../node_modules/viem/constants/strings.ts","../../../node_modules/viem/utils/signature/toPrefixedMessage.ts","../../../node_modules/viem/utils/signature/hashMessage.ts","../../../node_modules/viem/accounts/utils/signMessage.ts","../../../node_modules/viem/utils/blob/blobsToCommitments.ts","../../../node_modules/viem/utils/blob/blobsToProofs.ts","../../../node_modules/viem/utils/hash/sha256.ts","../../../node_modules/viem/utils/blob/commitmentToVersionedHash.ts","../../../node_modules/viem/utils/blob/commitmentsToVersionedHashes.ts","../../../node_modules/viem/constants/blob.ts","../../../node_modules/viem/constants/kzg.ts","../../../node_modules/viem/errors/blob.ts","../../../node_modules/viem/utils/blob/toBlobs.ts","../../../node_modules/viem/utils/blob/toBlobSidecars.ts","../../../node_modules/viem/experimental/eip7702/utils/serializeAuthorizationList.ts","../../../node_modules/viem/utils/transaction/assertTransaction.ts","../../../node_modules/viem/utils/transaction/getTransactionType.ts","../../../node_modules/viem/utils/transaction/serializeAccessList.ts","../../../node_modules/viem/utils/transaction/serializeTransaction.ts","../../../node_modules/viem/accounts/utils/signTransaction.ts","../../../node_modules/viem/errors/typedData.ts","../../../node_modules/viem/utils/typedData.ts","../../../node_modules/viem/utils/signature/hashTypedData.ts","../../../node_modules/viem/accounts/utils/signTypedData.ts","../../../node_modules/viem/accounts/privateKeyToAccount.ts","../src/client.ts","../src/utils.ts","../src/post.ts","../src/prompts.ts","../src/memory.ts","../src/actions.ts","../src/interactions.ts","../src/providers/StorjProvider.ts"],"sourcesContent":["import { Client, IAgentRuntime, elizaLogger } from \"@elizaos/core\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { LensClient } from \"./client\";\nimport { LensPostManager } from \"./post\";\nimport { LensInteractionManager } from \"./interactions\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport class LensAgentClient implements Client {\n    client: LensClient;\n    posts: LensPostManager;\n    interactions: LensInteractionManager;\n\n    private profileId: `0x${string}`;\n    private ipfs: StorjProvider;\n\n    constructor(public runtime: IAgentRuntime) {\n        const cache = new Map<string, any>();\n\n        const privateKey = runtime.getSetting(\n            \"EVM_PRIVATE_KEY\"\n        ) as `0x${string}`;\n        if (!privateKey) {\n            throw new Error(\"EVM_PRIVATE_KEY is missing\");\n        }\n        const account = privateKeyToAccount(privateKey);\n\n        this.profileId = runtime.getSetting(\n            \"LENS_PROFILE_ID\"\n        )! as `0x${string}`;\n\n        this.client = new LensClient({\n            runtime: this.runtime,\n            account,\n            cache,\n            profileId: this.profileId,\n        });\n\n        elizaLogger.info(\"Lens client initialized.\");\n\n        this.ipfs = new StorjProvider(runtime);\n\n        this.posts = new LensPostManager(\n            this.client,\n            this.runtime,\n            this.profileId,\n            cache,\n            this.ipfs\n        );\n\n        this.interactions = new LensInteractionManager(\n            this.client,\n            this.runtime,\n            this.profileId,\n            cache,\n            this.ipfs\n        );\n    }\n\n    async start() {\n        await Promise.all([this.posts.start(), this.interactions.start()]);\n    }\n\n    async stop() {\n        await Promise.all([this.posts.stop(), this.interactions.stop()]);\n    }\n}\n","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = SHA256_IV[0] | 0;\n  B = SHA256_IV[1] | 0;\n  C = SHA256_IV[2] | 0;\n  D = SHA256_IV[3] | 0;\n  E = SHA256_IV[4] | 0;\n  F = SHA256_IV[5] | 0;\n  G = SHA256_IV[6] | 0;\n  H = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).\n\nimport type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../errors/address.js'\nimport {\n  type IsAddressErrorType,\n  isAddress,\n} from '../utils/address/isAddress.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport type {\n  AccountSource,\n  CustomSource,\n  JsonRpcAccount,\n  LocalAccount,\n} from './types.js'\n\ntype GetAccountReturnType<accountSource extends AccountSource> =\n  | (accountSource extends Address ? JsonRpcAccount : never)\n  | (accountSource extends CustomSource ? LocalAccount : never)\n\nexport type ToAccountErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a custom signing implementation.\n *\n * @returns A Local Account.\n */\nexport function toAccount<accountSource extends AccountSource>(\n  source: accountSource,\n): GetAccountReturnType<accountSource> {\n  if (typeof source === 'string') {\n    if (!isAddress(source, { strict: false }))\n      throw new InvalidAddressError({ address: source })\n    return {\n      address: source,\n      type: 'json-rpc',\n    } as GetAccountReturnType<accountSource>\n  }\n\n  if (!isAddress(source.address, { strict: false }))\n    throw new InvalidAddressError({ address: source.address })\n  return {\n    address: source.address,\n    nonceManager: source.nonceManager,\n    sign: source.sign,\n    experimental_signAuthorization: source.experimental_signAuthorization,\n    signMessage: source.signMessage,\n    signTransaction: source.signTransaction,\n    signTypedData: source.signTypedData,\n    source: 'custom',\n    type: 'local',\n  } as GetAccountReturnType<accountSource>\n}\n","import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\n\nexport type PublicKeyToAddressErrorType =\n  | ChecksumAddressErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nexport function publicKeyToAddress(publicKey: Hex): Address {\n  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)\n  return checksumAddress(`0x${address}`) as Address\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type HexToBigIntErrorType, hexToBigInt } from '../encoding/fromHex.js'\nimport { hexToBytes } from '../encoding/toBytes.js'\nimport type { ToHexErrorType } from '../encoding/toHex.js'\n\ntype To = 'bytes' | 'hex'\n\nexport type SerializeSignatureParameters<to extends To = 'hex'> = Signature & {\n  to?: to | To | undefined\n}\n\nexport type SerializeSignatureReturnType<to extends To = 'hex'> =\n  | (to extends 'hex' ? Hex : never)\n  | (to extends 'bytes' ? ByteArray : never)\n\nexport type SerializeSignatureErrorType =\n  | HexToBigIntErrorType\n  | ToHexErrorType\n  | ErrorType\n\n/**\n * @description Converts a signature into hex format.\n *\n * @param signature The signature to convert.\n * @returns The signature in hex format.\n *\n * @example\n * serializeSignature({\n *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',\n *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',\n *   yParity: 1\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function serializeSignature<to extends To = 'hex'>({\n  r,\n  s,\n  to = 'hex',\n  v,\n  yParity,\n}: SerializeSignatureParameters<to>): SerializeSignatureReturnType<to> {\n  const yParity_ = (() => {\n    if (yParity === 0 || yParity === 1) return yParity\n    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0\n    throw new Error('Invalid `v` or `yParity` value')\n  })()\n  const signature = `0x${new secp256k1.Signature(\n    hexToBigInt(r),\n    hexToBigInt(s),\n  ).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}` as const\n\n  if (to === 'hex') return signature as SerializeSignatureReturnType<to>\n  return hexToBytes(signature) as SerializeSignatureReturnType<to>\n}\n","// TODO(v3): Convert to sync.\n\nimport { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignParameters<to extends To = 'object'> = {\n  hash: Hex\n  privateKey: Hex\n  to?: to | To | undefined\n}\n\nexport type SignReturnType<to extends To = 'object'> =\n  | (to extends 'object' ? Signature : never)\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type SignErrorType = NumberToHexErrorType | ErrorType\n\nlet extraEntropy: Hex | boolean = false\n\n/**\n * Sets extra entropy for signing functions.\n */\nexport function setSignEntropy(entropy: true | Hex) {\n  if (!entropy) throw new Error('must be a `true` or a hex value.')\n  extraEntropy = entropy\n}\n\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign<to extends To = 'object'>({\n  hash,\n  privateKey,\n  to = 'object',\n}: SignParameters<to>): Promise<SignReturnType<to>> {\n  const { r, s, recovery } = secp256k1.sign(\n    hash.slice(2),\n    privateKey.slice(2),\n    { lowS: true, extraEntropy },\n  )\n  const signature = {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    v: recovery ? 28n : 27n,\n    yParity: recovery,\n  }\n  return (() => {\n    if (to === 'bytes' || to === 'hex')\n      return serializeSignature({ ...signature, to })\n    return signature\n  })() as SignReturnType<to>\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../../types/misc.js'\nimport {\n  type ConcatHexErrorType,\n  concatHex,\n} from '../../../utils/data/concat.js'\nimport {\n  type HexToBytesErrorType,\n  hexToBytes,\n} from '../../../utils/encoding/toBytes.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../../utils/encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../../../utils/encoding/toRlp.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../../utils/hash/keccak256.js'\nimport type { Authorization } from '../types/authorization.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashAuthorizationParameters<to extends To> = Authorization & {\n  /** Output format. @default \"hex\" */\n  to?: to | To | undefined\n}\n\nexport type HashAuthorizationReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashAuthorizationErrorType =\n  | Keccak256ErrorType\n  | ConcatHexErrorType\n  | ToRlpErrorType\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n */\nexport function hashAuthorization<to extends To = 'hex'>(\n  parameters: HashAuthorizationParameters<to>,\n): HashAuthorizationReturnType<to> {\n  const { chainId, contractAddress, nonce, to } = parameters\n  const hash = keccak256(\n    concatHex([\n      '0x05',\n      toRlp([\n        chainId ? numberToHex(chainId) : '0x',\n        contractAddress,\n        nonce ? numberToHex(nonce) : '0x',\n      ]),\n    ]),\n  )\n  if (to === 'bytes') return hexToBytes(hash) as HashAuthorizationReturnType<to>\n  return hash as HashAuthorizationReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Authorization,\n  SignedAuthorization,\n} from '../../experimental/eip7702/types/authorization.js'\nimport {\n  type HashAuthorizationErrorType,\n  hashAuthorization,\n} from '../../experimental/eip7702/utils/hashAuthorization.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type SignErrorType,\n  type SignParameters,\n  type SignReturnType,\n  sign,\n} from './sign.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignAuthorizationParameters<to extends To = 'object'> =\n  Authorization & {\n    /** The private key to sign with. */\n    privateKey: Hex\n    to?: SignParameters<to>['to'] | undefined\n  }\n\nexport type SignAuthorizationReturnType<to extends To = 'object'> = Prettify<\n  to extends 'object' ? SignedAuthorization : SignReturnType<to>\n>\n\nexport type SignAuthorizationErrorType =\n  | SignErrorType\n  | HashAuthorizationErrorType\n  | ErrorType\n\n/**\n * Signs an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n */\nexport async function experimental_signAuthorization<to extends To = 'object'>(\n  parameters: SignAuthorizationParameters<to>,\n): Promise<SignAuthorizationReturnType<to>> {\n  const {\n    contractAddress,\n    chainId,\n    nonce,\n    privateKey,\n    to = 'object',\n  } = parameters\n  const signature = await sign({\n    hash: hashAuthorization({ contractAddress, chainId, nonce }),\n    privateKey,\n    to,\n  })\n  if (to === 'object')\n    return {\n      contractAddress,\n      chainId,\n      nonce,\n      ...(signature as Signature),\n    } as any\n  return signature as any\n}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { size } from '../data/size.js'\nimport {\n  type BytesToHexErrorType,\n  type StringToHexErrorType,\n  bytesToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type ToPrefixedMessageErrorType =\n  | ConcatErrorType\n  | StringToHexErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nexport function toPrefixedMessage(message_: SignableMessage): Hex {\n  const message = (() => {\n    if (typeof message_ === 'string') return stringToHex(message_)\n    if (typeof message_.raw === 'string') return message_.raw\n    return bytesToHex(message_.raw)\n  })()\n  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)\n  return concat([prefix, message])\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { toPrefixedMessage } from './toPrefixedMessage.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessageReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType = Keccak256ErrorType | ErrorType\n\nexport function hashMessage<to extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: to | undefined,\n): HashMessageReturnType<to> {\n  return keccak256(toPrefixedMessage(message), to_)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport {\n  type HashMessageErrorType,\n  hashMessage,\n} from '../../utils/signature/hashMessage.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignMessageParameters = {\n  /** The message to sign. */\n  message: SignableMessage\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignMessageReturnType = Hex\n\nexport type SignMessageErrorType =\n  | SignErrorType\n  | HashMessageErrorType\n  | ErrorType\n\n/**\n * @description Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):\n * `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * @returns The signature.\n */\nexport async function signMessage({\n  message,\n  privateKey,\n}: SignMessageParameters): Promise<SignMessageReturnType> {\n  return await sign({ hash: hashMessage(message), privateKey, to: 'hex' })\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type BlobsToCommitmentsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[] =\n    | readonly ByteArray[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform into commitments. */\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type BlobsToCommitmentsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type BlobsToCommitmentsErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\n): BlobsToCommitmentsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const commitments: ByteArray[] = []\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (to === 'bytes'\n    ? commitments\n    : commitments.map((x) =>\n        bytesToHex(x),\n      )) as {} as BlobsToCommitmentsReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Sha256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<to>\n  return toHex(bytes) as Sha256Hash<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentToVersionedHashParameters<\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\n  to extends To | undefined = undefined,\n> = {\n  /** Commitment from blob. */\n  commitment: commitment | Uint8Array | Hex\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hash. */\n  version?: number | undefined\n}\n\nexport type CommitmentToVersionedHashReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type CommitmentToVersionedHashErrorType =\n  | Sha256ErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex | ByteArray,\n  to extends To =\n    | (commitment extends Hex ? 'hex' : never)\n    | (commitment extends ByteArray ? 'bytes' : never),\n>(\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\n): CommitmentToVersionedHashReturnType<to> {\n  const { commitment, version = 1 } = parameters\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\n\n  const versionedHash = sha256(commitment, 'bytes')\n  versionedHash.set([version], 0)\n  return (\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\n  ) as CommitmentToVersionedHashReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentsToVersionedHashesParameters<\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\n    | readonly Uint8Array[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Commitments from blobs. */\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type CommitmentsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\n  to extends To =\n    | (commitments extends readonly Hex[] ? 'hex' : never)\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\n): CommitmentsToVersionedHashesReturnType<to> {\n  const { commitments, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\nexport const versionedHashVersionKzg = 1\n","import { versionedHashVersionKzg } from '../constants/kzg.js'\nimport type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\n  name: 'BlobSizeTooLargeError'\n}\nexport class BlobSizeTooLargeError extends BaseError {\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n      name: 'BlobSizeTooLargeError',\n    })\n  }\n}\n\nexport type EmptyBlobErrorType = EmptyBlobError & {\n  name: 'EmptyBlobError'\n}\nexport class EmptyBlobError extends BaseError {\n  constructor() {\n    super('Blob data must not be empty.', { name: 'EmptyBlobError' })\n  }\n}\n\nexport type InvalidVersionedHashSizeErrorType =\n  InvalidVersionedHashSizeError & {\n    name: 'InvalidVersionedHashSizeError'\n  }\nexport class InvalidVersionedHashSizeError extends BaseError {\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hash\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n      name: 'InvalidVersionedHashSizeError',\n    })\n  }\n}\n\nexport type InvalidVersionedHashVersionErrorType =\n  InvalidVersionedHashVersionError & {\n    name: 'InvalidVersionedHashVersionError'\n  }\nexport class InvalidVersionedHashVersionError extends BaseError {\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hash\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version}`,\n      ],\n      name: 'InvalidVersionedHashVersionError',\n    })\n  }\n}\n","import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from './blobsToCommitments.js'\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobSidecarsParameters<\n  data extends Hex | ByteArray | undefined = undefined,\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Return type. */\n  to?: to | To | undefined\n} & OneOf<\n  | {\n      /** Data to transform into blobs. */\n      data: data | Hex | ByteArray\n      /** KZG implementation. */\n      kzg: Kzg\n    }\n  | {\n      /** Blobs. */\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\n      /** Commitment for each blob. */\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\n      /** Proof for each blob. */\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\n    }\n>\n\nexport type ToBlobSidecarsReturnType<to extends To> =\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\n\nexport type ToBlobSidecarsErrorType =\n  | BlobsToCommitmentsErrorType\n  | ToBlobsErrorType\n  | blobsToProofsErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars<\n  const data extends Hex | ByteArray | undefined = undefined,\n  const blobs extends\n    | readonly Hex[]\n    | readonly ByteArray[]\n    | undefined = undefined,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never)\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\n): ToBlobSidecarsReturnType<to> {\n  const { data, kzg, to } = parameters\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\n  const commitments =\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\n  const proofs =\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\n\n  const sidecars: BlobSidecars = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i],\n    })\n\n  return sidecars as ToBlobSidecarsReturnType<to>\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport { toHex } from '../../../utils/encoding/toHex.js'\nimport { toYParitySignatureArray } from '../../../utils/transaction/serializeTransaction.js'\nimport type {\n  AuthorizationList,\n  SerializedAuthorizationList,\n} from '../types/authorization.js'\n\nexport type SerializeAuthorizationListReturnType = SerializedAuthorizationList\n\nexport type SerializeAuthorizationListErrorType = ErrorType\n\n/*\n * Serializes an EIP-7702 authorization list.\n */\nexport function serializeAuthorizationList(\n  authorizationList?: AuthorizationList<number, true> | undefined,\n): SerializeAuthorizationListReturnType {\n  if (!authorizationList || authorizationList.length === 0) return []\n\n  const serializedAuthorizationList = []\n  for (const authorization of authorizationList) {\n    const { contractAddress, chainId, nonce, ...signature } = authorization\n    serializedAuthorizationList.push([\n      chainId ? toHex(chainId) : '0x',\n      contractAddress,\n      nonce ? toHex(nonce) : '0x',\n      ...toYParitySignatureArray({}, signature),\n    ])\n  }\n\n  return serializedAuthorizationList as {} as SerializeAuthorizationListReturnType\n}\n","import { versionedHashVersionKzg } from '../../constants/kzg.js'\nimport { maxUint256 } from '../../constants/number.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n  InvalidVersionedHashSizeError,\n  type InvalidVersionedHashSizeErrorType,\n  InvalidVersionedHashVersionError,\n  type InvalidVersionedHashVersionErrorType,\n} from '../../errors/blob.js'\nimport {\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from '../../errors/chain.js'\nimport {\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n} from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nexport type AssertTransactionEIP7702ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | ErrorType\n\nexport function assertTransactionEIP7702(\n  transaction: TransactionSerializableEIP7702,\n) {\n  const { authorizationList } = transaction\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const { contractAddress, chainId } = authorization\n      if (!isAddress(contractAddress))\n        throw new InvalidAddressError({ address: contractAddress })\n      if (chainId < 0) throw new InvalidChainIdError({ chainId })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP4844ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | EmptyBlobErrorType\n  | InvalidVersionedHashSizeErrorType\n  | InvalidVersionedHashVersionErrorType\n  | ErrorType\n\nexport function assertTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n) {\n  const { blobVersionedHashes } = transaction\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\n    for (const hash of blobVersionedHashes) {\n      const size_ = size(hash)\n      const version = hexToNumber(slice(hash, 0, 1))\n      if (size_ !== 32)\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\n      if (version !== versionedHashVersionKzg)\n        throw new InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP1559ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | TipAboveFeeCapErrorType\n  | ErrorType\n\nexport function assertTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxFeePerGas && maxFeePerGas > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n\nexport type AssertTransactionEIP2930ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n\nexport type AssertTransactionLegacyErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new InvalidChainIdError({ chainId })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n","import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n} from '../../index.js'\nimport type {\n  TransactionRequestGeneric,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n} from '../../types/transaction.js'\nimport type { Assign, ExactPartial, IsNever, OneOf } from '../../types/utils.js'\n\nexport type GetTransactionType<\n  transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  > = TransactionSerializableGeneric,\n  result =\n    | (transaction extends LegacyProperties ? 'legacy' : never)\n    | (transaction extends EIP1559Properties ? 'eip1559' : never)\n    | (transaction extends EIP2930Properties ? 'eip2930' : never)\n    | (transaction extends EIP4844Properties ? 'eip4844' : never)\n    | (transaction extends EIP7702Properties ? 'eip7702' : never)\n    | (transaction['type'] extends TransactionSerializableGeneric['type']\n        ? Extract<transaction['type'], string>\n        : never),\n> = IsNever<keyof transaction> extends true\n  ? string\n  : IsNever<result> extends false\n    ? result\n    : string\n\nexport type GetTransactionTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  const transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  >,\n>(transaction: transaction): GetTransactionType<transaction> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<transaction>\n\n  if (typeof transaction.authorizationList !== 'undefined')\n    return 'eip7702' as any\n\n  if (\n    typeof transaction.blobs !== 'undefined' ||\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n    typeof transaction.sidecars !== 'undefined'\n  )\n    return 'eip4844' as any\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  ) {\n    return 'eip1559' as any\n  }\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\n    return 'legacy' as any\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype BaseProperties = {\n  accessList?: undefined\n  authorizationList?: undefined\n  blobs?: undefined\n  blobVersionedHashes?: undefined\n  gasPrice?: undefined\n  maxFeePerBlobGas?: undefined\n  maxFeePerGas?: undefined\n  maxPriorityFeePerGas?: undefined\n  sidecars?: undefined\n}\n\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\ntype EIP1559Properties = Assign<\n  BaseProperties,\n  OneOf<\n    | {\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\n      }\n    | {\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\n      },\n    FeeValuesEIP1559\n  > & {\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\n  }\n>\ntype EIP2930Properties = Assign<\n  ExactPartial<LegacyProperties>,\n  {\n    accessList: TransactionSerializableEIP2930['accessList']\n  }\n>\ntype EIP4844Properties = Assign<\n  ExactPartial<EIP1559Properties>,\n  ExactPartial<FeeValuesEIP4844> &\n    OneOf<\n      | {\n          blobs: TransactionSerializableEIP4844['blobs']\n        }\n      | {\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\n        }\n      | {\n          sidecars: TransactionSerializableEIP4844['sidecars']\n        },\n      TransactionSerializableEIP4844\n    >\n>\ntype EIP7702Properties = Assign<\n  ExactPartial<EIP1559Properties>,\n  {\n    authorizationList: TransactionSerializableEIP7702['authorizationList']\n  }\n>\n","import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { AccessList } from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\n\nexport type SerializeAccessListErrorType =\n  | InvalidStorageKeySizeErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/*\n * Serialize an  EIP-2930 access list\n * @remarks\n * Use to create a transaction serializer with support for EIP-2930 access lists\n *\n * @param accessList - Array of objects of address and arrays of Storage Keys\n * @throws InvalidAddressError, InvalidStorageKeySizeError\n * @returns Array of hex strings\n */\nexport function serializeAccessList(\n  accessList?: AccessList | undefined,\n): RecursiveArray<Hex> {\n  if (!accessList || accessList.length === 0) return []\n\n  const serializedAccessList = []\n  for (let i = 0; i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i]\n\n    for (let j = 0; j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\n      }\n    }\n\n    if (!isAddress(address, { strict: false })) {\n      throw new InvalidAddressError({ address })\n    }\n\n    serializedAccessList.push([address, storageKeys])\n  }\n  return serializedAccessList\n}\n","import {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  Signature,\n  SignatureLegacy,\n} from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedEIP7702,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from '../blob/blobsToCommitments.js'\nimport {\n  blobsToProofs,\n  type blobsToProofsErrorType,\n} from '../blob/blobsToProofs.js'\nimport {\n  type CommitmentsToVersionedHashesErrorType,\n  commitmentsToVersionedHashes,\n} from '../blob/commitmentsToVersionedHashes.js'\nimport {\n  type ToBlobSidecarsErrorType,\n  toBlobSidecars,\n} from '../blob/toBlobSidecars.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { trim } from '../data/trim.js'\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\n\nimport {\n  type SerializeAuthorizationListErrorType,\n  serializeAuthorizationList,\n} from '../../experimental/eip7702/utils/serializeAuthorizationList.js'\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionEIP4844ErrorType,\n  type AssertTransactionEIP7702ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionEIP4844,\n  assertTransactionEIP7702,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetTransactionType,\n  type GetTransactionTypeErrorType,\n  getTransactionType,\n} from './getTransactionType.js'\nimport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './serializeAccessList.js'\n\nexport type SerializedTransactionReturnType<\n  transaction extends TransactionSerializable = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n> = TransactionSerialized<_transactionType>\n\nexport type SerializeTransactionFn<\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = never,\n> = typeof serializeTransaction<\n  OneOf<TransactionSerializable | transaction>,\n  _transactionType\n>\n\nexport type SerializeTransactionErrorType =\n  | GetTransactionTypeErrorType\n  | SerializeTransactionEIP1559ErrorType\n  | SerializeTransactionEIP2930ErrorType\n  | SerializeTransactionEIP4844ErrorType\n  | SerializeTransactionEIP7702ErrorType\n  | SerializeTransactionLegacyErrorType\n  | ErrorType\n\nexport function serializeTransaction<\n  const transaction extends TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n>(\n  transaction: transaction,\n  signature?: Signature | undefined,\n): SerializedTransactionReturnType<transaction, _transactionType> {\n  const type = getTransactionType(transaction) as GetTransactionType\n\n  if (type === 'eip1559')\n    return serializeTransactionEIP1559(\n      transaction as TransactionSerializableEIP1559,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip2930')\n    return serializeTransactionEIP2930(\n      transaction as TransactionSerializableEIP2930,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip4844')\n    return serializeTransactionEIP4844(\n      transaction as TransactionSerializableEIP4844,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip7702')\n    return serializeTransactionEIP7702(\n      transaction as TransactionSerializableEIP7702,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  return serializeTransactionLegacy(\n    transaction as TransactionSerializableLegacy,\n    signature as SignatureLegacy,\n  ) as SerializedTransactionReturnType<transaction>\n}\n\ntype SerializeTransactionEIP7702ErrorType =\n  | AssertTransactionEIP7702ErrorType\n  | SerializeAuthorizationListErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP7702(\n  transaction: TransactionSerializableEIP7702,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP7702 {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP7702(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n  const serializedAuthorizationList =\n    serializeAuthorizationList(authorizationList)\n\n  return concatHex([\n    '0x04',\n    toRlp([\n      toHex(chainId),\n      nonce ? toHex(nonce) : '0x',\n      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n      maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n      gas ? toHex(gas) : '0x',\n      to ?? '0x',\n      value ? toHex(value) : '0x',\n      data ?? '0x',\n      serializedAccessList,\n      serializedAuthorizationList,\n      ...toYParitySignatureArray(transaction, signature),\n    ]),\n  ]) as TransactionSerializedEIP7702\n}\n\ntype SerializeTransactionEIP4844ErrorType =\n  | AssertTransactionEIP4844ErrorType\n  | BlobsToCommitmentsErrorType\n  | CommitmentsToVersionedHashesErrorType\n  | blobsToProofsErrorType\n  | ToBlobSidecarsErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP4844 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP4844(transaction)\n\n  let blobVersionedHashes = transaction.blobVersionedHashes\n  let sidecars = transaction.sidecars\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\n  if (\n    transaction.blobs &&\n    (typeof blobVersionedHashes === 'undefined' ||\n      typeof sidecars === 'undefined')\n  ) {\n    const blobs = (\n      typeof transaction.blobs[0] === 'string'\n        ? transaction.blobs\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\n    ) as Hex[]\n    const kzg = transaction.kzg!\n    const commitments = blobsToCommitments({\n      blobs,\n      kzg,\n    })\n\n    if (typeof blobVersionedHashes === 'undefined')\n      blobVersionedHashes = commitmentsToVersionedHashes({\n        commitments,\n      })\n    if (typeof sidecars === 'undefined') {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\n    }\n  }\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...toYParitySignatureArray(transaction, signature),\n  ] as const\n\n  const blobs: Hex[] = []\n  const commitments: Hex[] = []\n  const proofs: Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return concatHex([\n    '0x03',\n    sidecars\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\n        toRlp([serializedTransaction, blobs, commitments, proofs])\n      : // If sidecars are disabled, standard envelope is used:\n        toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP4844\n}\n\ntype SerializeTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP1559 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP1559(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x02',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP1559\n}\n\ntype SerializeTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP2930 {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\n    transaction\n\n  assertTransactionEIP2930(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x01',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP2930\n}\n\ntype SerializeTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nfunction serializeTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n  signature?: SignatureLegacy | undefined,\n): TransactionSerializedLegacy {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\n\n  assertTransactionLegacy(transaction)\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n  ]\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n\n        if (inferredChainId > 0) return signature.v\n        return 27n + (signature.v === 35n ? 0n : 1n)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\n      return v\n    })()\n\n    const r = trim(signature.r)\n    const s = trim(signature.s)\n\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(v),\n      r === '0x00' ? '0x' : r,\n      s === '0x00' ? '0x' : s,\n    ]\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      '0x',\n      '0x',\n    ]\n  }\n\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\n}\n\nexport function toYParitySignatureArray(\n  transaction: TransactionSerializableGeneric,\n  signature_?: Signature | undefined,\n) {\n  const signature = signature_ ?? transaction\n  const { v, yParity } = signature\n\n  if (typeof signature.r === 'undefined') return []\n  if (typeof signature.s === 'undefined') return []\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\n\n  const r = trim(signature.r)\n  const s = trim(signature.s)\n\n  const yParity_ = (() => {\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\n    if (v === 0n) return '0x'\n    if (v === 1n) return toHex(1)\n\n    return v === 27n ? '0x' : toHex(1)\n  })()\n\n  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s]\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerialized,\n} from '../../types/transaction.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\nimport type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'\nimport {\n  type SerializeTransactionFn,\n  serializeTransaction,\n} from '../../utils/transaction/serializeTransaction.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTransactionParameters<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n> = {\n  privateKey: Hex\n  transaction: transaction\n  serializer?: serializer | undefined\n}\n\nexport type SignTransactionReturnType<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n> = TransactionSerialized<GetTransactionType<transaction>>\n\nexport type SignTransactionErrorType =\n  | Keccak256ErrorType\n  | SignErrorType\n  | ErrorType\n\nexport async function signTransaction<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n>(\n  parameters: SignTransactionParameters<serializer, transaction>,\n): Promise<SignTransactionReturnType<serializer, transaction>> {\n  const {\n    privateKey,\n    transaction,\n    serializer = serializeTransaction,\n  } = parameters\n\n  const signableTransaction = (() => {\n    // For EIP-4844 Transactions, we want to sign the transaction payload body (tx_payload_body) without the sidecars (ie. without the network wrapper).\n    // See: https://github.com/ethereum/EIPs/blob/e00f4daa66bd56e2dbd5f1d36d09fd613811a48b/EIPS/eip-4844.md#networking\n    if (transaction.type === 'eip4844')\n      return {\n        ...transaction,\n        sidecars: false,\n      }\n    return transaction\n  })()\n\n  const signature = await sign({\n    hash: keccak256(serializer(signableTransaction)),\n    privateKey,\n  })\n  return serializer(transaction, signature) as SignTransactionReturnType<\n    serializer,\n    transaction\n  >\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","import type { TypedData } from 'abitype'\n\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type HashTypedDataErrorType,\n  hashTypedData,\n} from '../../utils/signature/hashTypedData.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignTypedDataReturnType = Hex\n\nexport type SignTypedDataErrorType =\n  | HashTypedDataErrorType\n  | SignErrorType\n  | ErrorType\n\n/**\n * @description Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):\n * `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * @returns The signature.\n */\nexport async function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: SignTypedDataParameters<typedData, primaryType>,\n): Promise<SignTypedDataReturnType> {\n  const { privateKey, ...typedData } =\n    parameters as unknown as SignTypedDataParameters\n  return await sign({\n    hash: hashTypedData(typedData),\n    privateKey,\n    to: 'hex',\n  })\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { Hex } from '../types/misc.js'\nimport { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport type { NonceManager } from '../utils/nonceManager.js'\nimport { type ToAccountErrorType, toAccount } from './toAccount.js'\nimport type { PrivateKeyAccount } from './types.js'\nimport {\n  type PublicKeyToAddressErrorType,\n  publicKeyToAddress,\n} from './utils/publicKeyToAddress.js'\nimport { type SignErrorType, sign } from './utils/sign.js'\nimport { experimental_signAuthorization } from './utils/signAuthorization.js'\nimport { type SignMessageErrorType, signMessage } from './utils/signMessage.js'\nimport {\n  type SignTransactionErrorType,\n  signTransaction,\n} from './utils/signTransaction.js'\nimport {\n  type SignTypedDataErrorType,\n  signTypedData,\n} from './utils/signTypedData.js'\n\nexport type PrivateKeyToAccountOptions = {\n  nonceManager?: NonceManager | undefined\n}\n\nexport type PrivateKeyToAccountErrorType =\n  | ToAccountErrorType\n  | ToHexErrorType\n  | PublicKeyToAddressErrorType\n  | SignErrorType\n  | SignMessageErrorType\n  | SignTransactionErrorType\n  | SignTypedDataErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a private key.\n *\n * @returns A Private Key Account.\n */\nexport function privateKeyToAccount(\n  privateKey: Hex,\n  options: PrivateKeyToAccountOptions = {},\n): PrivateKeyAccount {\n  const { nonceManager } = options\n  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false))\n  const address = publicKeyToAddress(publicKey)\n\n  const account = toAccount({\n    address,\n    nonceManager,\n    async sign({ hash }) {\n      return sign({ hash, privateKey, to: 'hex' })\n    },\n    async experimental_signAuthorization(authorization) {\n      return experimental_signAuthorization({ ...authorization, privateKey })\n    },\n    async signMessage({ message }) {\n      return signMessage({ message, privateKey })\n    },\n    async signTransaction(transaction, { serializer } = {}) {\n      return signTransaction({ privateKey, transaction, serializer })\n    },\n    async signTypedData(typedData) {\n      return signTypedData({ ...typedData, privateKey } as any)\n    },\n  })\n\n  return {\n    ...account,\n    publicKey,\n    source: 'privateKey',\n  } as PrivateKeyAccount\n}\n","import { IAgentRuntime, elizaLogger } from \"@elizaos/core\";\nimport {\n    AnyPublicationFragment,\n    LensClient as LensClientCore,\n    production,\n    LensTransactionStatusType,\n    LimitType,\n    NotificationType,\n    ProfileFragment,\n    PublicationType,\n    FeedEventItemType,\n} from \"@lens-protocol/client\";\nimport { Profile, BroadcastResult } from \"./types\";\nimport { PrivateKeyAccount } from \"viem\";\nimport { getProfilePictureUri, handleBroadcastResult, omit } from \"./utils\";\n\nexport class LensClient {\n    runtime: IAgentRuntime;\n    account: PrivateKeyAccount;\n    cache: Map<string, any>;\n    lastInteractionTimestamp: Date;\n    profileId: `0x${string}`;\n\n    private authenticated: boolean;\n    private authenticatedProfile: ProfileFragment | null;\n    private core: LensClientCore;\n\n    constructor(opts: {\n        runtime: IAgentRuntime;\n        cache: Map<string, any>;\n        account: PrivateKeyAccount;\n        profileId: `0x${string}`;\n    }) {\n        this.cache = opts.cache;\n        this.runtime = opts.runtime;\n        this.account = opts.account;\n        this.core = new LensClientCore({\n            environment: production,\n        });\n        this.lastInteractionTimestamp = new Date();\n        this.profileId = opts.profileId;\n        this.authenticated = false;\n        this.authenticatedProfile = null;\n    }\n\n    async authenticate(): Promise<void> {\n        try {\n            const { id, text } =\n                await this.core.authentication.generateChallenge({\n                    signedBy: this.account.address,\n                    for: this.profileId,\n                });\n\n            const signature = await this.account.signMessage({\n                message: text,\n            });\n\n            await this.core.authentication.authenticate({ id, signature });\n            this.authenticatedProfile = await this.core.profile.fetch({\n                forProfileId: this.profileId,\n            });\n\n            this.authenticated = true;\n        } catch (error) {\n            elizaLogger.error(\"client-lens::client error: \", error);\n            throw error;\n        }\n    }\n\n    async createPublication(\n        contentURI: string,\n        onchain: boolean = false,\n        commentOn?: string\n    ): Promise<AnyPublicationFragment | null | undefined> {\n        try {\n            if (!this.authenticated) {\n                await this.authenticate();\n                elizaLogger.log(\"done authenticating\");\n            }\n            let broadcastResult;\n\n            if (commentOn) {\n                broadcastResult = onchain\n                    ? await this.createCommentOnchain(contentURI, commentOn)\n                    : await this.createCommentMomoka(contentURI, commentOn);\n            } else {\n                broadcastResult = onchain\n                    ? await this.createPostOnchain(contentURI)\n                    : await this.createPostMomoka(contentURI);\n            }\n\n            elizaLogger.log(\"broadcastResult\", broadcastResult);\n\n            if (broadcastResult.id) {\n                return await this.core.publication.fetch({\n                    forId: broadcastResult.id,\n                });\n            }\n\n            const completion = await this.core.transaction.waitUntilComplete({\n                forTxHash: broadcastResult.txHash,\n            });\n\n            if (completion?.status === LensTransactionStatusType.Complete) {\n                return await this.core.publication.fetch({\n                    forTxHash: completion?.txHash,\n                });\n            }\n        } catch (error) {\n            elizaLogger.error(\"client-lens::client error: \", error);\n            throw error;\n        }\n    }\n\n    async getPublication(\n        pubId: string\n    ): Promise<AnyPublicationFragment | null> {\n        if (this.cache.has(`lens/publication/${pubId}`)) {\n            return this.cache.get(`lens/publication/${pubId}`);\n        }\n\n        const publication = await this.core.publication.fetch({ forId: pubId });\n\n        if (publication)\n            this.cache.set(`lens/publication/${pubId}`, publication);\n\n        return publication;\n    }\n\n    async getPublicationsFor(\n        profileId: string,\n        limit: number = 50\n    ): Promise<AnyPublicationFragment[]> {\n        const timeline: AnyPublicationFragment[] = [];\n        let next: any | undefined = undefined;\n\n        do {\n            const { items, next: newNext } = next\n                ? await next()\n                : await this.core.publication.fetchAll({\n                      limit: LimitType.Fifty,\n                      where: {\n                          from: [profileId],\n                          publicationTypes: [PublicationType.Post],\n                      },\n                  });\n\n            items.forEach((publication) => {\n                this.cache.set(\n                    `lens/publication/${publication.id}`,\n                    publication\n                );\n                timeline.push(publication);\n            });\n\n            next = newNext;\n        } while (next && timeline.length < limit);\n\n        return timeline;\n    }\n\n    async getMentions(): Promise<{\n        mentions: AnyPublicationFragment[];\n        next?: () => {};\n    }> {\n        if (!this.authenticated) {\n            await this.authenticate();\n        }\n        // TODO: we should limit to new ones or at least latest n\n        const result = await this.core.notifications.fetch({\n            where: {\n                highSignalFilter: false, // true,\n                notificationTypes: [\n                    NotificationType.Mentioned,\n                    NotificationType.Commented,\n                ],\n            },\n        });\n        const mentions: AnyPublicationFragment[] = [];\n\n        const { items, next } = result.unwrap();\n\n        items.map((notification) => {\n            // @ts-ignore NotificationFragment\n            const item = notification.publication || notification.comment;\n            if (!item.isEncrypted) {\n                mentions.push(item);\n                this.cache.set(`lens/publication/${item.id}`, item);\n            }\n        });\n\n        return { mentions, next };\n    }\n\n    async getProfile(profileId: string): Promise<Profile> {\n        if (this.cache.has(`lens/profile/${profileId}`)) {\n            return this.cache.get(`lens/profile/${profileId}`) as Profile;\n        }\n\n        const result = await this.core.profile.fetch({\n            forProfileId: profileId,\n        });\n        if (!result?.id) {\n            elizaLogger.error(\"Error fetching user by profileId\");\n\n            throw \"getProfile ERROR\";\n        }\n\n        const profile: Profile = {\n            id: \"\",\n            profileId,\n            name: \"\",\n            handle: \"\",\n        };\n\n        profile.id = result.id;\n        profile.name = result.metadata?.displayName;\n        profile.handle = result.handle?.localName;\n        profile.bio = result.metadata?.bio;\n        profile.pfp = getProfilePictureUri(result.metadata?.picture);\n\n        this.cache.set(`lens/profile/${profileId}`, profile);\n\n        return profile;\n    }\n\n    async getTimeline(\n        profileId: string,\n        limit: number = 10\n    ): Promise<AnyPublicationFragment[]> {\n        try {\n            if (!this.authenticated) {\n                await this.authenticate();\n            }\n            const timeline: AnyPublicationFragment[] = [];\n            let next: any | undefined = undefined;\n\n            do {\n                const result = next\n                    ? await next()\n                    : await this.core.feed.fetch({\n                          where: {\n                              for: profileId,\n                              feedEventItemTypes: [FeedEventItemType.Post],\n                          },\n                      });\n\n                const data = result.unwrap();\n\n                data.items.forEach((item) => {\n                    // private posts in orb clubs are encrypted\n                    if (timeline.length < limit && !item.root.isEncrypted) {\n                        this.cache.set(\n                            `lens/publication/${item.id}`,\n                            item.root\n                        );\n                        timeline.push(item.root as AnyPublicationFragment);\n                    }\n                });\n\n                next = data.pageInfo.next;\n            } while (next && timeline.length < limit);\n\n            return timeline;\n        } catch (error) {\n            console.log(error);\n            throw new Error(\"client-lens:: getTimeline\");\n        }\n    }\n\n    private async createPostOnchain(\n        contentURI: string\n    ): Promise<BroadcastResult | undefined> {\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.postOnchain({\n                contentURI,\n                openActionModules: [], // TODO: if collectable\n            });\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createOnchainPostTypedData({\n                contentURI,\n                openActionModules: [], // TODO: if collectable\n            });\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Post\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnchain({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n\n    private async createPostMomoka(\n        contentURI: string\n    ): Promise<BroadcastResult | undefined> {\n        console.log(\"createPostMomoka\");\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.postOnMomoka({\n                contentURI,\n            });\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createMomokaPostTypedData({\n                contentURI,\n            });\n        console.log(\"typedDataResult\", typedDataResult);\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Post\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnMomoka({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n\n    private async createCommentOnchain(\n        contentURI: string,\n        commentOn: string\n    ): Promise<BroadcastResult | undefined> {\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.commentOnchain({\n                commentOn,\n                contentURI,\n            });\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createOnchainCommentTypedData({\n                commentOn,\n                contentURI,\n            });\n\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Comment\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnchain({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n\n    private async createCommentMomoka(\n        contentURI: string,\n        commentOn: string\n    ): Promise<BroadcastResult | undefined> {\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.commentOnMomoka(\n                {\n                    commentOn,\n                    contentURI,\n                }\n            );\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createMomokaCommentTypedData({\n                commentOn,\n                contentURI,\n            });\n\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Comment\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnMomoka({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n}\n","import { stringToUuid } from \"@elizaos/core\";\nimport { BroadcastResult } from \"./types\";\n\nexport function publicationId({\n    pubId,\n    agentId,\n}: {\n    pubId: string;\n    agentId: string;\n}) {\n    return `${pubId}-${agentId}`;\n}\n\nexport function publicationUuid(props: { pubId: string; agentId: string }) {\n    return stringToUuid(publicationId(props));\n}\n\nexport function populateMentions(\n    text: string,\n    userIds: number[],\n    positions: number[],\n    userMap: Record<number, string>\n) {\n    // Validate input arrays have same length\n    if (userIds.length !== positions.length) {\n        throw new Error(\n            \"User IDs and positions arrays must have the same length\"\n        );\n    }\n\n    // Create array of mention objects with position and user info\n    const mentions = userIds\n        .map((userId, index) => ({\n            position: positions[index],\n            userId,\n            displayName: userMap[userId]!,\n        }))\n        .sort((a, b) => b.position - a.position); // Sort in reverse order to prevent position shifting\n\n    // Create the resulting string by inserting mentions\n    let result = text;\n    mentions.forEach((mention) => {\n        const mentionText = `@${mention.displayName}`;\n        result =\n            result.slice(0, mention.position) +\n            mentionText +\n            result.slice(mention.position);\n    });\n\n    return result;\n}\n\nexport const handleBroadcastResult = (\n    broadcastResult: any\n): BroadcastResult | undefined => {\n    const broadcastValue = broadcastResult.unwrap();\n\n    if (\"id\" in broadcastValue || \"txId\" in broadcastValue) {\n        return broadcastValue;\n    } else {\n        throw new Error();\n    }\n};\n\nexport const getProfilePictureUri = (picture: any): string | undefined => {\n    if (\"optimized\" in picture) {\n        return picture.optimized?.uri || picture.raw?.uri || picture.uri;\n    } else {\n        return picture.uri;\n    }\n};\n\nexport function omit<T extends object, K extends string>(\n    obj: T,\n    key: K\n): Omit<T, K> {\n    const result: any = {};\n    Object.keys(obj).forEach((currentKey) => {\n        if (currentKey !== key) {\n            result[currentKey] = obj[currentKey];\n        }\n    });\n    return result;\n}\n","import {\n    composeContext,\n    generateText,\n    IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { LensClient } from \"./client\";\nimport { formatTimeline, postTemplate } from \"./prompts\";\nimport { publicationUuid } from \"./utils\";\nimport { createPublicationMemory } from \"./memory\";\nimport { sendPublication } from \"./actions\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport class LensPostManager {\n    private timeout: NodeJS.Timeout | undefined;\n\n    constructor(\n        public client: LensClient,\n        public runtime: IAgentRuntime,\n        private profileId: string,\n        public cache: Map<string, any>,\n        private ipfs: StorjProvider\n    ) {}\n\n    public async start() {\n        const generateNewPubLoop = async () => {\n            try {\n                await this.generateNewPublication();\n            } catch (error) {\n                elizaLogger.error(error);\n                return;\n            }\n\n            this.timeout = setTimeout(\n                generateNewPubLoop,\n                (Math.floor(Math.random() * (4 - 1 + 1)) + 1) * 60 * 60 * 1000\n            ); // Random interval between 1 and 4 hours\n        };\n\n        generateNewPubLoop();\n    }\n\n    public async stop() {\n        if (this.timeout) clearTimeout(this.timeout);\n    }\n\n    private async generateNewPublication() {\n        elizaLogger.info(\"Generating new publication\");\n        try {\n            const profile = await this.client.getProfile(this.profileId);\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                profile.handle!,\n                this.runtime.character.name,\n                \"lens\"\n            );\n\n            const timeline = await this.client.getTimeline(this.profileId);\n\n            // this.cache.set(\"lens/timeline\", timeline);\n\n            const formattedHomeTimeline = formatTimeline(\n                this.runtime.character,\n                timeline\n            );\n\n            const generateRoomId = stringToUuid(\"lens_generate_room\");\n\n            const state = await this.runtime.composeState(\n                {\n                    roomId: generateRoomId,\n                    userId: this.runtime.agentId,\n                    agentId: this.runtime.agentId,\n                    content: { text: \"\", action: \"\" },\n                },\n                {\n                    lensHandle: profile.handle,\n                    timeline: formattedHomeTimeline,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.lensPostTemplate ||\n                    postTemplate,\n            });\n\n            const content = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (this.runtime.getSetting(\"LENS_DRY_RUN\") === \"true\") {\n                elizaLogger.info(`Dry run: would have posted: ${content}`);\n                return;\n            }\n\n            try {\n                const { publication } = await sendPublication({\n                    client: this.client,\n                    runtime: this.runtime,\n                    roomId: generateRoomId,\n                    content: { text: content },\n                    ipfs: this.ipfs,\n                });\n\n                if (!publication) throw new Error(\"failed to send publication\");\n\n                const roomId = publicationUuid({\n                    agentId: this.runtime.agentId,\n                    pubId: publication.id,\n                });\n\n                await this.runtime.ensureRoomExists(roomId);\n\n                await this.runtime.ensureParticipantInRoom(\n                    this.runtime.agentId,\n                    roomId\n                );\n\n                elizaLogger.info(`[Lens Client] Published ${publication.id}`);\n\n                await this.runtime.messageManager.createMemory(\n                    createPublicationMemory({\n                        roomId,\n                        runtime: this.runtime,\n                        publication,\n                    })\n                );\n            } catch (error) {\n                elizaLogger.error(\"Error sending publication:\", error);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error generating new publication:\", error);\n        }\n    }\n}\n","import {\n    Character,\n    messageCompletionFooter,\n    shouldRespondFooter,\n} from \"@elizaos/core\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\n\nexport const formatPublication = (publication: AnyPublicationFragment) => {\n    return `ID: ${publication.id}\n    From: ${publication.by.metadata?.displayName} (@${publication.by.handle?.localName})${publication.by.handle?.localName})${publication.commentOn ? `\\nIn reply to: @${publication.commentOn.by.handle?.localName}` : \"\"}\nText: ${publication.metadata.content}`;\n};\n\nexport const formatTimeline = (\n    character: Character,\n    timeline: AnyPublicationFragment[]\n) => `# ${character.name}'s Home Timeline\n${timeline.map(formatPublication).join(\"\\n\")}\n`;\n\nexport const headerTemplate = `\n{{timeline}}\n\n# Knowledge\n{{knowledge}}\n\nAbout {{agentName}} (@{{lensHandle}}):\n{{bio}}\n{{lore}}\n{{postDirections}}\n\n{{providers}}\n\n{{recentPosts}}\n\n{{characterPostExamples}}`;\n\nexport const postTemplate =\n    headerTemplate +\n    `\n# Task: Generate a post in the voice and style of {{agentName}}, aka @{{lensHandle}}\nWrite a single sentence post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}.\nTry to write something totally different than previous posts. Do not add commentary or ackwowledge this request, just write the post.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.`;\n\nexport const messageHandlerTemplate =\n    headerTemplate +\n    `\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nThread of publications You Are Replying To:\n{{formattedConversation}}\n\n# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{lensHandle}}):\n{{currentPost}}` +\n    messageCompletionFooter;\n\nexport const shouldRespondTemplate =\n    //\n    `# Task: Decide if {{agentName}} should respond.\n    About {{agentName}}:\n    {{bio}}\n\n    # INSTRUCTIONS: Determine if {{agentName}} (@{{lensHandle}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\n{{agentName}} should respond to messages that are directed at them, or participate in conversations that are interesting or relevant to their background, IGNORE messages that are irrelevant to them, and should STOP if the conversation is concluded.\n\n{{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n{{agentName}} should RESPOND to messages that are directed at them, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting or relevant, {{agentName}} should IGNORE.\nIf a message thread has become repetitive, {{agentName}} should IGNORE.\nUnless directly RESPONDing to a user, {{agentName}} should IGNORE messages that are very short or do not contain much information.\nIf a user asks {{agentName}} to stop talking, {{agentName}} should STOP.\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, {{agentName}} should STOP.\n\nIMPORTANT: {{agentName}} (aka @{{lensHandle}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n\nThread of messages You Are Replying To:\n{{formattedConversation}}\n\nCurrent message:\n{{currentPost}}\n\n` + shouldRespondFooter;\n","import {\n    elizaLogger,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    stringToUuid,\n    type Memory,\n    type UUID,\n} from \"@elizaos/core\";\nimport { publicationUuid } from \"./utils\";\nimport { LensClient } from \"./client\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\n\nexport function createPublicationMemory({\n    roomId,\n    runtime,\n    publication,\n}: {\n    roomId: UUID;\n    runtime: IAgentRuntime;\n    publication: AnyPublicationFragment;\n}): Memory {\n    const commentOn = publication.commentOn\n        ? publicationUuid({\n              pubId: publication.commentOn.id,\n              agentId: runtime.agentId,\n          })\n        : undefined;\n\n    return {\n        id: publicationUuid({\n            pubId: publication.id,\n            agentId: runtime.agentId,\n        }),\n        agentId: runtime.agentId,\n        userId: runtime.agentId,\n        content: {\n            text: publication.metadata.content,\n            source: \"lens\",\n            url: \"\",\n            commentOn,\n            id: publication.id,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n    };\n}\n\nexport async function buildConversationThread({\n    publication,\n    runtime,\n    client,\n}: {\n    publication: AnyPublicationFragment;\n    runtime: IAgentRuntime;\n    client: LensClient;\n}): Promise<AnyPublicationFragment[]> {\n    const thread: AnyPublicationFragment[] = [];\n    const visited: Set<string> = new Set();\n    async function processThread(currentPublication: AnyPublicationFragment) {\n        if (visited.has(currentPublication.id)) {\n            return;\n        }\n\n        visited.add(currentPublication.id);\n\n        const roomId = publicationUuid({\n            pubId: currentPublication.id,\n            agentId: runtime.agentId,\n        });\n\n        // Check if the current cast has already been saved\n        const memory = await runtime.messageManager.getMemoryById(roomId);\n\n        if (!memory) {\n            elizaLogger.log(\n                \"Creating memory for publication\",\n                currentPublication.id\n            );\n\n            const userId = stringToUuid(currentPublication.by.id);\n\n            await runtime.ensureConnection(\n                userId,\n                roomId,\n                currentPublication.by.id,\n                currentPublication.by.metadata?.displayName ||\n                    currentPublication.by.handle?.localName,\n                \"lens\"\n            );\n\n            await runtime.messageManager.createMemory(\n                createPublicationMemory({\n                    roomId,\n                    runtime,\n                    publication: currentPublication,\n                })\n            );\n        }\n\n        thread.unshift(currentPublication);\n\n        if (currentPublication.commentOn) {\n            const parentPublication = await client.getPublication(\n                currentPublication.commentOn.id\n            );\n            if (parentPublication) await processThread(parentPublication);\n        }\n    }\n\n    await processThread(publication);\n    return thread;\n}\n","import type { LensClient } from \"./client\";\nimport {\n    elizaLogger,\n    type Content,\n    type IAgentRuntime,\n    type Memory,\n    type UUID,\n} from \"@elizaos/core\";\nimport { textOnly } from \"@lens-protocol/metadata\";\nimport { createPublicationMemory } from \"./memory\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport async function sendPublication({\n    client,\n    runtime,\n    content,\n    roomId,\n    commentOn,\n    ipfs,\n}: {\n    client: LensClient;\n    runtime: IAgentRuntime;\n    content: Content;\n    roomId: UUID;\n    commentOn?: string;\n    ipfs: StorjProvider;\n}): Promise<{ memory?: Memory; publication?: AnyPublicationFragment }> {\n    // TODO: arweave provider for content hosting\n    const metadata = textOnly({ content: content.text });\n    const contentURI = await ipfs.pinJson(metadata);\n\n    const publication = await client.createPublication(\n        contentURI,\n        false, // TODO: support collectable settings\n        commentOn\n    );\n\n    if (publication) {\n        return {\n            publication,\n            memory: createPublicationMemory({\n                roomId,\n                runtime,\n                publication: publication as AnyPublicationFragment,\n            }),\n        };\n    }\n\n    return {};\n}\n","import {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    Memory,\n    ModelClass,\n    stringToUuid,\n    elizaLogger,\n    HandlerCallback,\n    Content,\n    type IAgentRuntime,\n} from \"@elizaos/core\";\nimport type { LensClient } from \"./client\";\nimport { toHex } from \"viem\";\nimport { buildConversationThread, createPublicationMemory } from \"./memory\";\nimport {\n    formatPublication,\n    formatTimeline,\n    messageHandlerTemplate,\n    shouldRespondTemplate,\n} from \"./prompts\";\nimport { publicationUuid } from \"./utils\";\nimport { sendPublication } from \"./actions\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\nimport { Profile } from \"./types\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport class LensInteractionManager {\n    private timeout: NodeJS.Timeout | undefined;\n    constructor(\n        public client: LensClient,\n        public runtime: IAgentRuntime,\n        private profileId: string,\n        public cache: Map<string, any>,\n        private ipfs: StorjProvider\n    ) {}\n\n    public async start() {\n        const handleInteractionsLoop = async () => {\n            try {\n                await this.handleInteractions();\n            } catch (error) {\n                elizaLogger.error(error);\n                return;\n            }\n\n            this.timeout = setTimeout(\n                handleInteractionsLoop,\n                Number(this.runtime.getSetting(\"LENS_POLL_INTERVAL\") || 120) *\n                    1000 // Default to 2 minutes\n            );\n        };\n\n        handleInteractionsLoop();\n    }\n\n    public async stop() {\n        if (this.timeout) clearTimeout(this.timeout);\n    }\n\n    private async handleInteractions() {\n        elizaLogger.info(\"Handle Lens interactions\");\n        // TODO: handle next() for pagination\n        const { mentions } = await this.client.getMentions();\n\n        const agent = await this.client.getProfile(this.profileId);\n        for (const mention of mentions) {\n            const messageHash = toHex(mention.id);\n            const conversationId = `${messageHash}-${this.runtime.agentId}`;\n            const roomId = stringToUuid(conversationId);\n            const userId = stringToUuid(mention.by.id);\n\n            const pastMemoryId = publicationUuid({\n                agentId: this.runtime.agentId,\n                pubId: mention.id,\n            });\n\n            const pastMemory =\n                await this.runtime.messageManager.getMemoryById(pastMemoryId);\n\n            if (pastMemory) {\n                continue;\n            }\n\n            await this.runtime.ensureConnection(\n                userId,\n                roomId,\n                mention.by.id,\n                mention.by.metadata?.displayName ||\n                    mention.by.handle?.localName,\n                \"lens\"\n            );\n\n            const thread = await buildConversationThread({\n                client: this.client,\n                runtime: this.runtime,\n                publication: mention,\n            });\n\n            const memory: Memory = {\n                // @ts-ignore Metadata\n                content: { text: mention.metadata.content, hash: mention.id },\n                agentId: this.runtime.agentId,\n                userId,\n                roomId,\n            };\n\n            await this.handlePublication({\n                agent,\n                publication: mention,\n                memory,\n                thread,\n            });\n        }\n\n        this.client.lastInteractionTimestamp = new Date();\n    }\n\n    private async handlePublication({\n        agent,\n        publication,\n        memory,\n        thread,\n    }: {\n        agent: Profile;\n        publication: AnyPublicationFragment;\n        memory: Memory;\n        thread: AnyPublicationFragment[];\n    }) {\n        if (publication.by.id === agent.id) {\n            elizaLogger.info(\"skipping cast from bot itself\", publication.id);\n            return;\n        }\n\n        if (!memory.content.text) {\n            elizaLogger.info(\"skipping cast with no text\", publication.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        const currentPost = formatPublication(publication);\n\n        const timeline = await this.client.getTimeline(this.profileId);\n\n        const formattedTimeline = formatTimeline(\n            this.runtime.character,\n            timeline\n        );\n\n        const formattedConversation = thread\n            .map((pub) => {\n                // @ts-ignore Metadata\n                const content = pub.metadata.content;\n                return `@${pub.by.handle?.localName} (${new Date(\n                    pub.createdAt\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n                ${content}`;\n            })\n            .join(\"\\n\\n\");\n\n        const state = await this.runtime.composeState(memory, {\n            lensHandle: agent.handle,\n            timeline: formattedTimeline,\n            currentPost,\n            formattedConversation,\n        });\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.lensShouldRespondTemplate ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                shouldRespondTemplate,\n        });\n\n        const memoryId = publicationUuid({\n            agentId: this.runtime.agentId,\n            pubId: publication.id,\n        });\n\n        const castMemory =\n            await this.runtime.messageManager.getMemoryById(memoryId);\n\n        if (!castMemory) {\n            await this.runtime.messageManager.createMemory(\n                createPublicationMemory({\n                    roomId: memory.roomId,\n                    runtime: this.runtime,\n                    publication,\n                })\n            );\n        }\n\n        const shouldRespondResponse = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.SMALL,\n        });\n\n        if (\n            shouldRespondResponse === \"IGNORE\" ||\n            shouldRespondResponse === \"STOP\"\n        ) {\n            elizaLogger.info(\n                `Not responding to publication because generated ShouldRespond was ${shouldRespondResponse}`\n            );\n            return;\n        }\n\n        const context = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.lensMessageHandlerTemplate ??\n                this.runtime.character?.templates?.messageHandlerTemplate ??\n                messageHandlerTemplate,\n        });\n\n        const responseContent = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        responseContent.inReplyTo = memoryId;\n\n        if (!responseContent.text) return;\n\n        if (this.runtime.getSetting(\"LENS_DRY_RUN\") === \"true\") {\n            elizaLogger.info(\n                `Dry run: would have responded to publication ${publication.id} with ${responseContent.text}`\n            );\n            return;\n        }\n\n        const callback: HandlerCallback = async (\n            content: Content,\n            files: any[]\n        ) => {\n            try {\n                if (memoryId && !content.inReplyTo) {\n                    content.inReplyTo = memoryId;\n                }\n                const result = await sendPublication({\n                    runtime: this.runtime,\n                    client: this.client,\n                    content: content,\n                    roomId: memory.roomId,\n                    commentOn: publication.id,\n                    ipfs: this.ipfs,\n                });\n                if (!result.publication?.id)\n                    throw new Error(\"publication not sent\");\n\n                // sendPublication lost response action, so we need to add it back here?\n                result.memory!.content.action = content.action;\n\n                await this.runtime.messageManager.createMemory(result.memory!);\n                return [result.memory!];\n            } catch (error) {\n                console.error(\"Error sending response cast:\", error);\n                return [];\n            }\n        };\n\n        const responseMessages = await callback(responseContent);\n\n        const newState = await this.runtime.updateRecentMessageState(state);\n\n        await this.runtime.processActions(\n            memory,\n            responseMessages,\n            newState,\n            callback\n        );\n    }\n}\n","import axios, { AxiosInstance } from \"axios\";\nimport FormData from \"form-data\";\nimport type { IAgentRuntime } from \"@elizaos/core\";\n\n// ipfs pinning service: https://storj.dev/dcs/api/storj-ipfs-pinning\nclass StorjProvider {\n    private STORJ_API_URL: string = \"https://www.storj-ipfs.com\";\n    private STORJ_API_USERNAME: string;\n    private STORJ_API_PASSWORD: string;\n    private baseURL: string;\n    private client: AxiosInstance;\n\n    constructor(runtime: IAgentRuntime) {\n        this.STORJ_API_USERNAME = runtime.getSetting(\"STORJ_API_USERNAME\")!;\n        this.STORJ_API_PASSWORD = runtime.getSetting(\"STORJ_API_PASSWORD\")!;\n        this.baseURL = `${this.STORJ_API_URL}/api/v0`;\n        this.client = this.createClient();\n    }\n\n    private createClient(): AxiosInstance {\n        return axios.create({\n            baseURL: this.baseURL,\n            auth: {\n                username: this.STORJ_API_USERNAME,\n                password: this.STORJ_API_PASSWORD,\n            },\n        });\n    }\n\n    private hash(uriOrHash: string): string {\n        return typeof uriOrHash === \"string\" && uriOrHash.startsWith(\"ipfs://\")\n            ? uriOrHash.split(\"ipfs://\")[1]\n            : uriOrHash;\n    }\n\n    public gatewayURL(uriOrHash: string): string {\n        return `${this.STORJ_API_URL}/ipfs/${this.hash(uriOrHash)}`;\n    }\n\n    public async pinJson(json: any): Promise<string> {\n        if (typeof json !== \"string\") {\n            json = JSON.stringify(json);\n        }\n        const formData = new FormData();\n        formData.append(\"path\", Buffer.from(json, \"utf-8\").toString());\n\n        const headers = {\n            \"Content-Type\": \"multipart/form-data\",\n            ...formData.getHeaders(),\n        };\n\n        const { data } = await this.client.post(\n            \"add?cid-version=1\",\n            formData.getBuffer(),\n            { headers }\n        );\n\n        return this.gatewayURL(data.Hash);\n    }\n\n    public async pinFile(file: {\n        buffer: Buffer;\n        originalname: string;\n        mimetype: string;\n    }): Promise<string> {\n        const formData = new FormData();\n        formData.append(\"file\", file.buffer, {\n            filename: file.originalname,\n            contentType: file.mimetype,\n        });\n\n        const response = await this.client.post(\"add?cid-version=1\", formData, {\n            headers: {\n                \"Content-Type\": `multipart/form-data; boundary=${formData.getBoundary()}`,\n            },\n            maxContentLength: Infinity,\n            maxBodyLength: Infinity,\n        });\n\n        return this.gatewayURL(response.data.Hash);\n    }\n}\n\nexport default StorjProvider;\n"],"mappings":"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","names":["elizaLogger","sha256","toBytes","sha256","size","size","blobs","commitments","proofs","v","struct","broadcastResult","stringToUuid","elizaLogger","elizaLogger","stringToUuid","elizaLogger","stringToUuid","elizaLogger","stringToUuid","composeContext","ModelClass","stringToUuid","elizaLogger","elizaLogger","stringToUuid","composeContext","ModelClass","elizaLogger"]}