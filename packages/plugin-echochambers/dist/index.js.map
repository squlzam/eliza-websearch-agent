{"version":3,"sources":["../src/index.ts","../src/echoChamberClient.ts","../src/interactions.ts","../src/environment.ts","../src/types.ts"],"sourcesContent":["import { elizaLogger, Client, IAgentRuntime, Plugin } from \"@elizaos/core\";\nimport { EchoChamberClient } from \"./echoChamberClient\";\nimport { InteractionClient } from \"./interactions\";\nimport { EchoChamberConfig } from \"./types\";\nimport { validateEchoChamberConfig } from \"./environment\";\n\nexport const EchoChamberClientInterface: Client = {\n    async start(runtime: IAgentRuntime) {\n        try {\n            // Validate configuration before starting\n            await validateEchoChamberConfig(runtime);\n\n            const apiUrl = runtime.getSetting(\"ECHOCHAMBERS_API_URL\");\n            const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\n\n            if (!apiKey || !apiUrl) {\n                throw new Error(\n                    \"ECHOCHAMBERS_API_KEY/ECHOCHAMBERS_API_URL is required\"\n                );\n            }\n\n            const config: EchoChamberConfig = {\n                apiUrl,\n                apiKey,\n                username:\n                    runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\n                    `agent-${runtime.agentId}`,\n                model: runtime.modelProvider,\n                defaultRoom:\n                    runtime.getSetting(\"ECHOCHAMBERS_DEFAULT_ROOM\") ||\n                    \"general\",\n            };\n\n            elizaLogger.log(\"Starting EchoChambers client...\");\n\n            // Initialize the API client\n            const client = new EchoChamberClient(runtime, config);\n            await client.start();\n\n            // Initialize the interaction handler\n            const interactionClient = new InteractionClient(client, runtime);\n            await interactionClient.start();\n\n            elizaLogger.success(\n                `‚úÖ EchoChambers client successfully started for character ${runtime.character.name}`\n            );\n\n            return { client, interactionClient };\n        } catch (error) {\n            elizaLogger.error(\"Failed to start EchoChambers client:\", error);\n            throw error;\n        }\n    },\n\n    async stop(runtime: IAgentRuntime) {\n        try {\n            elizaLogger.warn(\"Stopping EchoChambers client...\");\n\n            // Get client instances if they exist\n            const clients = (runtime as any).clients?.filter(\n                (c: any) =>\n                    c instanceof EchoChamberClient ||\n                    c instanceof InteractionClient\n            );\n\n            for (const client of clients) {\n                await client.stop();\n            }\n\n            elizaLogger.success(\"EchoChambers client stopped successfully\");\n        } catch (error) {\n            elizaLogger.error(\"Error stopping EchoChambers client:\", error);\n            throw error;\n        }\n    },\n};\n\nexport const echoChamberPlugin: Plugin = {\n    name: \"echochambers\",\n    description:\n        \"Plugin for interacting with EchoChambers API to enable multi-agent communication\",\n    actions: [], // No custom actions needed - core functionality handled by client\n    evaluators: [], // No custom evaluators needed\n    providers: [], // No custom providers needed\n    clients: [EchoChamberClientInterface],\n};\n\nexport default echoChamberPlugin;\n\n// Export types and classes\nexport * from \"./types\";\nexport { EchoChamberClient } from \"./echoChamberClient\";\nexport { InteractionClient } from \"./interactions\";\n","import { elizaLogger, IAgentRuntime } from \"@elizaos/core\";\nimport {\n    ChatMessage,\n    ChatRoom,\n    EchoChamberConfig,\n    ModelInfo,\n    ListRoomsResponse,\n    RoomHistoryResponse,\n    MessageResponse,\n} from \"./types\";\n\nconst MAX_RETRIES = 3;\n\nconst RETRY_DELAY = 5000;\n\nexport class EchoChamberClient {\n    private runtime: IAgentRuntime;\n    private config: EchoChamberConfig;\n    private apiUrl: string;\n    private modelInfo: ModelInfo;\n    private pollInterval: NodeJS.Timeout | null = null;\n    private watchedRoom: string | null = null;\n\n    constructor(runtime: IAgentRuntime, config: EchoChamberConfig) {\n        this.runtime = runtime;\n        this.config = config;\n        this.apiUrl = `${config.apiUrl}/api/rooms`;\n        this.modelInfo = {\n            username: config.username || `agent-${runtime.agentId}`,\n            model: config.model || runtime.modelProvider,\n        };\n    }\n\n    public getUsername(): string {\n        return this.modelInfo.username;\n    }\n\n    public getModelInfo(): ModelInfo {\n        return { ...this.modelInfo };\n    }\n\n    public getConfig(): EchoChamberConfig {\n        return { ...this.config };\n    }\n\n    private getAuthHeaders(): { [key: string]: string } {\n        return {\n            \"Content-Type\": \"application/json\",\n            \"x-api-key\": this.config.apiKey,\n        };\n    }\n\n    public async setWatchedRoom(roomId: string): Promise<void> {\n        try {\n            // Verify room exists\n            const rooms = await this.listRooms();\n            const room = rooms.find((r) => r.id === roomId);\n\n            if (!room) {\n                throw new Error(`Room ${roomId} not found`);\n            }\n\n            // Set new watched room\n            this.watchedRoom = roomId;\n\n            elizaLogger.success(`Now watching room: ${room.name}`);\n        } catch (error) {\n            elizaLogger.error(\"Error setting watched room:\", error);\n            throw error;\n        }\n    }\n\n    public getWatchedRoom(): string | null {\n        return this.watchedRoom;\n    }\n\n    private async retryOperation<T>(\n        operation: () => Promise<T>,\n        retries: number = MAX_RETRIES\n    ): Promise<T> {\n        for (let i = 0; i < retries; i++) {\n            try {\n                return await operation();\n            } catch (error) {\n                if (i === retries - 1) throw error;\n                const delay = RETRY_DELAY * Math.pow(2, i);\n                elizaLogger.warn(`Retrying operation in ${delay}ms...`);\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n        }\n        throw new Error(\"Max retries exceeded\");\n    }\n\n    public async start(): Promise<void> {\n        elizaLogger.log(\"üöÄ Starting EchoChamber client...\");\n        try {\n            // Verify connection by listing rooms\n            await this.retryOperation(() => this.listRooms());\n            elizaLogger.success(\n                `‚úÖ EchoChamber client successfully started for ${this.modelInfo.username}`\n            );\n\n            // Join default room if specified and no specific room is being watched\n            if (this.config.defaultRoom && !this.watchedRoom) {\n                await this.setWatchedRoom(this.config.defaultRoom);\n            }\n        } catch (error) {\n            elizaLogger.error(\"‚ùå Failed to start EchoChamber client:\", error);\n            throw error;\n        }\n    }\n\n    public async stop(): Promise<void> {\n        if (this.pollInterval) {\n            clearInterval(this.pollInterval);\n            this.pollInterval = null;\n        }\n\n        // Leave watched room if any\n        if (this.watchedRoom) {\n            try {\n                this.watchedRoom = null;\n            } catch (error) {\n                elizaLogger.error(\n                    `Error leaving room ${this.watchedRoom}:`,\n                    error\n                );\n            }\n        }\n\n        elizaLogger.log(\"Stopping EchoChamber client...\");\n    }\n\n    public async listRooms(tags?: string[]): Promise<ChatRoom[]> {\n        try {\n            const url = new URL(this.apiUrl);\n            if (tags?.length) {\n                url.searchParams.append(\"tags\", tags.join(\",\"));\n            }\n\n            const response = await fetch(url.toString());\n            if (!response.ok) {\n                throw new Error(`Failed to list rooms: ${response.statusText}`);\n            }\n\n            const data = (await response.json()) as ListRoomsResponse;\n            return data.rooms;\n        } catch (error) {\n            elizaLogger.error(\"Error listing rooms:\", error);\n            throw error;\n        }\n    }\n\n    public async getRoomHistory(roomId: string): Promise<ChatMessage[]> {\n        return this.retryOperation(async () => {\n            const response = await fetch(`${this.apiUrl}/${roomId}/history`);\n            if (!response.ok) {\n                throw new Error(\n                    `Failed to get room history: ${response.statusText}`\n                );\n            }\n\n            const data = (await response.json()) as RoomHistoryResponse;\n            return data.messages;\n        });\n    }\n\n    public async sendMessage(\n        roomId: string,\n        content: string\n    ): Promise<ChatMessage> {\n        return this.retryOperation(async () => {\n            const response = await fetch(`${this.apiUrl}/${roomId}/message`, {\n                method: \"POST\",\n                headers: this.getAuthHeaders(),\n                body: JSON.stringify({\n                    content,\n                    sender: this.modelInfo,\n                }),\n            });\n\n            if (!response.ok) {\n                throw new Error(\n                    `Failed to send message: ${response.statusText}`\n                );\n            }\n\n            const data = (await response.json()) as MessageResponse;\n            return data.message;\n        });\n    }\n}\n","import {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n} from \"@elizaos/core\";\nimport { EchoChamberClient } from \"./echoChamberClient\";\nimport { ChatMessage } from \"./types\";\n\nfunction createMessageTemplate(currentRoom: string, roomTopic: string) {\n    return (\n        `\n# About {{agentName}}:\n{{bio}}\n{{lore}}\n{{knowledge}}\n\nCurrent Room: ${currentRoom}\nRoom Topic: ${roomTopic}\n\n{{messageDirections}}\n\nRecent conversation history:\n{{recentMessages}}\n\nThread Context:\n{{formattedConversation}}\n\n# Task: Generate a response in the voice and style of {{agentName}} while:\n1. Staying relevant to the room's topic\n2. Maintaining conversation context\n3. Being helpful but not overly talkative\n4. Responding naturally to direct questions or mentions\n5. Contributing meaningfully to ongoing discussions\n\nRemember:\n- Keep responses concise and focused\n- Stay on topic for the current room\n- Don't repeat information already shared\n- Be natural and conversational\n` + messageCompletionFooter\n    );\n}\n\nfunction createShouldRespondTemplate(currentRoom: string, roomTopic: string) {\n    return (\n        `\n# About {{agentName}}:\n{{bio}}\n{{knowledge}}\n\nCurrent Room: ${currentRoom}\nRoom Topic: ${roomTopic}\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} should:\n- RESPOND when:\n  * Directly mentioned or asked a question\n  * Can contribute relevant expertise to the discussion\n  * Topic aligns with their knowledge and background\n  * Conversation is active and engaging\n\n- IGNORE when:\n  * Message is not relevant to their expertise\n  * Already responded recently without new information to add\n  * Conversation has moved to a different topic\n  * Message is too short or lacks substance\n  * Other participants are handling the discussion well\n\n- STOP when:\n  * Asked to stop participating\n  * Conversation has concluded\n  * Discussion has completely diverged from their expertise\n  * Room topic has changed significantly\n\nRecent messages:\n{{recentMessages}}\n\nThread Context:\n{{formattedConversation}}\n\n# Task: Choose whether {{agentName}} should respond to the last message.\nConsider:\n1. Message relevance to {{agentName}}'s expertise\n2. Current conversation context\n3. Time since last response\n4. Value of potential contribution\n` + shouldRespondFooter\n    );\n}\n\nexport class InteractionClient {\n    private client: EchoChamberClient;\n    private runtime: IAgentRuntime;\n    private lastCheckedTimestamps: Map<string, string> = new Map();\n    private lastResponseTimes: Map<string, number> = new Map();\n    private messageThreads: Map<string, ChatMessage[]> = new Map();\n    private messageHistory: Map<\n        string,\n        { message: ChatMessage; response: ChatMessage | null }[]\n    > = new Map();\n    private pollInterval: NodeJS.Timeout | null = null;\n\n    constructor(client: EchoChamberClient, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n    }\n\n    async start() {\n        const pollInterval = Number(\n            this.runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 60\n        );\n\n        const handleInteractionsLoop = () => {\n            this.handleInteractions();\n            this.pollInterval = setTimeout(\n                handleInteractionsLoop,\n                pollInterval * 1000\n            );\n        };\n\n        handleInteractionsLoop();\n    }\n\n    async stop() {\n        if (this.pollInterval) {\n            clearTimeout(this.pollInterval);\n            this.pollInterval = null;\n        }\n    }\n\n    private async buildMessageThread(\n        message: ChatMessage,\n        messages: ChatMessage[]\n    ): Promise<ChatMessage[]> {\n        const thread: ChatMessage[] = [];\n        const maxThreadLength = Number(\n            this.runtime.getSetting(\"ECHOCHAMBERS_MAX_MESSAGES\") || 10\n        );\n\n        // Start with the current message\n        thread.push(message);\n\n        // Get recent messages in the same room, ordered by timestamp\n        const roomMessages = messages\n            .filter((msg) => msg.roomId === message.roomId)\n            .sort(\n                (a, b) =>\n                    new Date(b.timestamp).getTime() -\n                    new Date(a.timestamp).getTime()\n            );\n\n        // Add recent messages to provide context\n        for (const msg of roomMessages) {\n            if (thread.length >= maxThreadLength) break;\n            if (msg.id !== message.id) {\n                thread.unshift(msg);\n            }\n        }\n\n        return thread;\n    }\n\n    private shouldProcessMessage(\n        message: ChatMessage,\n        room: { topic: string }\n    ): boolean {\n        const modelInfo = this.client.getModelInfo();\n\n        // Don't process own messages\n        if (message.sender.username === modelInfo.username) {\n            return false;\n        }\n\n        // Check if we've processed this message before\n        const lastChecked =\n            this.lastCheckedTimestamps.get(message.roomId) || \"0\";\n        if (message.timestamp <= lastChecked) {\n            return false;\n        }\n\n        // Check rate limiting for responses\n        const lastResponseTime =\n            this.lastResponseTimes.get(message.roomId) || 0;\n        const minTimeBetweenResponses = 30000; // 30 seconds\n        if (Date.now() - lastResponseTime < minTimeBetweenResponses) {\n            return false;\n        }\n\n        // Check if message mentions the agent\n        const isMentioned = message.content\n            .toLowerCase()\n            .includes(`${modelInfo.username.toLowerCase()}`);\n\n        // Check if message is relevant to room topic\n        const isRelevantToTopic =\n            room.topic &&\n            message.content.toLowerCase().includes(room.topic.toLowerCase());\n\n        // Always process if mentioned, otherwise check relevance\n        return isMentioned || isRelevantToTopic;\n    }\n\n    private async handleInteractions() {\n        elizaLogger.log(\"Checking EchoChambers interactions\");\n\n        try {\n            const defaultRoom = this.runtime.getSetting(\n                \"ECHOCHAMBERS_DEFAULT_ROOM\"\n            );\n            const rooms = await this.client.listRooms();\n\n            for (const room of rooms) {\n                // Only process messages from the default room if specified\n                if (defaultRoom && room.id !== defaultRoom) {\n                    continue;\n                }\n\n                const messages = await this.client.getRoomHistory(room.id);\n                this.messageThreads.set(room.id, messages);\n\n                // Get only the most recent message that we should process\n                const latestMessages = messages\n                    .filter((msg) => !this.shouldProcessMessage(msg, room)) // Fixed: Now filtering out messages we shouldn't process\n                    .sort(\n                        (a, b) =>\n                            new Date(b.timestamp).getTime() -\n                            new Date(a.timestamp).getTime()\n                    );\n\n                if (latestMessages.length > 0) {\n                    const latestMessage = latestMessages[0];\n                    await this.handleMessage(latestMessage, room.topic);\n\n                    // Update history\n                    const roomHistory = this.messageHistory.get(room.id) || [];\n                    roomHistory.push({\n                        message: latestMessage,\n                        response: null, // Will be updated when we respond\n                    });\n                    this.messageHistory.set(room.id, roomHistory);\n\n                    // Update last checked timestamp\n                    if (\n                        latestMessage.timestamp >\n                        (this.lastCheckedTimestamps.get(room.id) || \"0\")\n                    ) {\n                        this.lastCheckedTimestamps.set(\n                            room.id,\n                            latestMessage.timestamp\n                        );\n                    }\n                }\n            }\n\n            elizaLogger.log(\"Finished checking EchoChambers interactions\");\n        } catch (error) {\n            elizaLogger.error(\n                \"Error handling EchoChambers interactions:\",\n                error\n            );\n        }\n    }\n\n    private async handleMessage(message: ChatMessage, roomTopic: string) {\n        try {\n            const roomId = stringToUuid(message.roomId);\n            const userId = stringToUuid(message.sender.username);\n\n            // Ensure connection exists\n            await this.runtime.ensureConnection(\n                userId,\n                roomId,\n                message.sender.username,\n                message.sender.username,\n                \"echochambers\"\n            );\n\n            // Build message thread for context\n            const thread = await this.buildMessageThread(\n                message,\n                this.messageThreads.get(message.roomId) || []\n            );\n\n            // Create memory object\n            const memory: Memory = {\n                id: stringToUuid(message.id),\n                userId,\n                agentId: this.runtime.agentId,\n                roomId,\n                content: {\n                    text: message.content,\n                    source: \"echochambers\",\n                    thread: thread.map((msg) => ({\n                        text: msg.content,\n                        sender: msg.sender.username,\n                        timestamp: msg.timestamp,\n                    })),\n                },\n                createdAt: new Date(message.timestamp).getTime(),\n                embedding: getEmbeddingZeroVector(),\n            };\n\n            // Check if we've already processed this message\n            const existing = await this.runtime.messageManager.getMemoryById(\n                memory.id\n            );\n            if (existing) {\n                elizaLogger.log(\n                    `Already processed message ${message.id}, skipping`\n                );\n                return;\n            }\n\n            // Save the message to memory\n            await this.runtime.messageManager.createMemory(memory);\n\n            // Compose state with thread context\n            let state = await this.runtime.composeState(memory);\n            state = await this.runtime.updateRecentMessageState(state);\n\n            // Decide whether to respond\n            const shouldRespondContext = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.shouldRespondTemplate ||\n                    createShouldRespondTemplate(message.roomId, roomTopic),\n            });\n\n            const shouldRespond = await generateShouldRespond({\n                runtime: this.runtime,\n                context: shouldRespondContext,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (shouldRespond !== \"RESPOND\") {\n                elizaLogger.log(\n                    `Not responding to message ${message.id}: ${shouldRespond}`\n                );\n                return;\n            }\n\n            // Generate response\n            const responseContext = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.messageHandlerTemplate ||\n                    createMessageTemplate(message.roomId, roomTopic),\n            });\n\n            const response = await generateMessageResponse({\n                runtime: this.runtime,\n                context: responseContext,\n                modelClass: ModelClass.LARGE,\n            });\n\n            if (!response || !response.text) {\n                elizaLogger.log(\"No response generated\");\n                return;\n            }\n\n            // Send response\n            const callback: HandlerCallback = async (content: Content) => {\n                const sentMessage = await this.client.sendMessage(\n                    message.roomId,\n                    content.text\n                );\n\n                // Update last response time\n                this.lastResponseTimes.set(message.roomId, Date.now());\n\n                // Update history with our response\n                const roomHistory =\n                    this.messageHistory.get(message.roomId) || [];\n                const lastEntry = roomHistory[roomHistory.length - 1];\n                if (lastEntry && lastEntry.message.id === message.id) {\n                    lastEntry.response = sentMessage;\n                }\n\n                const responseMemory: Memory = {\n                    id: stringToUuid(sentMessage.id),\n                    userId: this.runtime.agentId,\n                    agentId: this.runtime.agentId,\n                    roomId,\n                    content: {\n                        text: sentMessage.content,\n                        source: \"echochambers\",\n                        action: content.action,\n                        thread: thread.map((msg) => ({\n                            text: msg.content,\n                            sender: msg.sender.username,\n                            timestamp: msg.timestamp,\n                        })),\n                    },\n                    createdAt: new Date(sentMessage.timestamp).getTime(),\n                    embedding: getEmbeddingZeroVector(),\n                };\n\n                await this.runtime.messageManager.createMemory(responseMemory);\n                return [responseMemory];\n            };\n\n            // Send the response and process any resulting actions\n            const responseMessages = await callback(response);\n            state = await this.runtime.updateRecentMessageState(state);\n            await this.runtime.processActions(\n                memory,\n                responseMessages,\n                state,\n                callback\n            );\n            await this.runtime.evaluate(memory, state, true);\n        } catch (error) {\n            elizaLogger.error(\"Error handling message:\", error);\n        }\n    }\n}\n","import { IAgentRuntime, elizaLogger } from \"@elizaos/core\";\n\nexport async function validateEchoChamberConfig(\n    runtime: IAgentRuntime\n): Promise<void> {\n    const apiUrl = runtime.getSetting(\"ECHOCHAMBERS_API_URL\");\n    const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\n\n    if (!apiUrl) {\n        elizaLogger.error(\n            \"ECHOCHAMBERS_API_URL is required. Please set it in your environment variables.\"\n        );\n        throw new Error(\"ECHOCHAMBERS_API_URL is required\");\n    }\n\n    if (!apiKey) {\n        elizaLogger.error(\n            \"ECHOCHAMBERS_API_KEY is required. Please set it in your environment variables.\"\n        );\n        throw new Error(\"ECHOCHAMBERS_API_KEY is required\");\n    }\n\n    // Validate API URL format\n    try {\n        new URL(apiUrl);\n    } catch (error) {\n        elizaLogger.error(\n            `Invalid ECHOCHAMBERS_API_URL format: ${apiUrl}. Please provide a valid URL.`\n        );\n        throw new Error(\"Invalid ECHOCHAMBERS_API_URL format\");\n    }\n\n    // Optional settings with defaults\n    const username =\n        runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\n        `agent-${runtime.agentId}`;\n    const defaultRoom =\n        runtime.getSetting(\"ECHOCHAMBERS_DEFAULT_ROOM\") || \"general\";\n    const pollInterval = Number(\n        runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 120\n    );\n\n    if (isNaN(pollInterval) || pollInterval < 1) {\n        elizaLogger.error(\n            \"ECHOCHAMBERS_POLL_INTERVAL must be a positive number in seconds\"\n        );\n        throw new Error(\"Invalid ECHOCHAMBERS_POLL_INTERVAL\");\n    }\n\n    elizaLogger.log(\"EchoChambers configuration validated successfully\");\n    elizaLogger.log(`API URL: ${apiUrl}`);\n    elizaLogger.log(`Username: ${username}`);\n    elizaLogger.log(`Default Room: ${defaultRoom}`);\n    elizaLogger.log(`Poll Interval: ${pollInterval}s`);\n}\n","export interface ModelInfo {\n    username: string; // Unique username for the model/agent\n    model: string; // Type/name of the model being used\n}\n\nexport interface ChatMessage {\n    id: string; // Unique message identifier\n    content: string; // Message content/text\n    sender: ModelInfo; // Information about who sent the message\n    timestamp: string; // ISO timestamp of when message was sent\n    roomId: string; // ID of the room this message belongs to\n}\n\nexport interface ChatRoom {\n    id: string; // Unique room identifier\n    name: string; // Display name of the room\n    topic: string; // Room's current topic/description\n    tags: string[]; // Tags associated with the room for categorization\n    participants: ModelInfo[]; // List of current room participants\n    createdAt: string; // ISO timestamp of room creation\n    messageCount: number; // Total number of messages in the room\n}\n\nexport interface EchoChamberConfig {\n    apiUrl: string; // Base URL for the EchoChambers API\n    apiKey: string; // Required API key for authenticated endpoints\n    defaultRoom?: string; // Optional default room to join on startup\n    username?: string; // Optional custom username (defaults to agent-{agentId})\n    model?: string; // Optional model name (defaults to runtime.modelProvider)\n}\n\nexport interface ListRoomsResponse {\n    rooms: ChatRoom[];\n}\n\nexport interface RoomHistoryResponse {\n    messages: ChatMessage[];\n}\n\nexport interface MessageResponse {\n    message: ChatMessage;\n}\n\nexport interface CreateRoomResponse {\n    room: ChatRoom;\n}\n\nexport interface ClearMessagesResponse {\n    success: boolean;\n    message: string;\n}\n\nexport enum RoomEvent {\n    MESSAGE_CREATED = \"message_created\",\n    ROOM_CREATED = \"room_created\",\n    ROOM_UPDATED = \"room_updated\",\n    ROOM_JOINED = \"room_joined\",\n    ROOM_LEFT = \"room_left\",\n}\n\nexport interface MessageTransformer {\n    transformIncoming(content: string): Promise<string>;\n    transformOutgoing?(content: string): Promise<string>;\n}\n\nexport interface ContentModerator {\n    validateContent(content: string): Promise<boolean>;\n}\n"],"mappings":";AAAA,SAAS,eAAAA,oBAAkD;;;ACA3D,SAAS,mBAAkC;AAW3C,IAAM,cAAc;AAEpB,IAAM,cAAc;AAEb,IAAM,oBAAN,MAAwB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,eAAsC;AAAA,EACtC,cAA6B;AAAA,EAErC,YAAY,SAAwB,QAA2B;AAC3D,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,SAAS,GAAG,OAAO,MAAM;AAC9B,SAAK,YAAY;AAAA,MACb,UAAU,OAAO,YAAY,SAAS,QAAQ,OAAO;AAAA,MACrD,OAAO,OAAO,SAAS,QAAQ;AAAA,IACnC;AAAA,EACJ;AAAA,EAEO,cAAsB;AACzB,WAAO,KAAK,UAAU;AAAA,EAC1B;AAAA,EAEO,eAA0B;AAC7B,WAAO,EAAE,GAAG,KAAK,UAAU;AAAA,EAC/B;AAAA,EAEO,YAA+B;AAClC,WAAO,EAAE,GAAG,KAAK,OAAO;AAAA,EAC5B;AAAA,EAEQ,iBAA4C;AAChD,WAAO;AAAA,MACH,gBAAgB;AAAA,MAChB,aAAa,KAAK,OAAO;AAAA,IAC7B;AAAA,EACJ;AAAA,EAEA,MAAa,eAAe,QAA+B;AACvD,QAAI;AAEA,YAAM,QAAQ,MAAM,KAAK,UAAU;AACnC,YAAM,OAAO,MAAM,KAAK,CAAC,MAAM,EAAE,OAAO,MAAM;AAE9C,UAAI,CAAC,MAAM;AACP,cAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AAAA,MAC9C;AAGA,WAAK,cAAc;AAEnB,kBAAY,QAAQ,sBAAsB,KAAK,IAAI,EAAE;AAAA,IACzD,SAAS,OAAO;AACZ,kBAAY,MAAM,+BAA+B,KAAK;AACtD,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEO,iBAAgC;AACnC,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,MAAc,eACV,WACA,UAAkB,aACR;AACV,aAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAC9B,UAAI;AACA,eAAO,MAAM,UAAU;AAAA,MAC3B,SAAS,OAAO;AACZ,YAAI,MAAM,UAAU,EAAG,OAAM;AAC7B,cAAM,QAAQ,cAAc,KAAK,IAAI,GAAG,CAAC;AACzC,oBAAY,KAAK,yBAAyB,KAAK,OAAO;AACtD,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,CAAC;AAAA,MAC7D;AAAA,IACJ;AACA,UAAM,IAAI,MAAM,sBAAsB;AAAA,EAC1C;AAAA,EAEA,MAAa,QAAuB;AAChC,gBAAY,IAAI,0CAAmC;AACnD,QAAI;AAEA,YAAM,KAAK,eAAe,MAAM,KAAK,UAAU,CAAC;AAChD,kBAAY;AAAA,QACR,sDAAiD,KAAK,UAAU,QAAQ;AAAA,MAC5E;AAGA,UAAI,KAAK,OAAO,eAAe,CAAC,KAAK,aAAa;AAC9C,cAAM,KAAK,eAAe,KAAK,OAAO,WAAW;AAAA,MACrD;AAAA,IACJ,SAAS,OAAO;AACZ,kBAAY,MAAM,8CAAyC,KAAK;AAChE,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,MAAa,OAAsB;AAC/B,QAAI,KAAK,cAAc;AACnB,oBAAc,KAAK,YAAY;AAC/B,WAAK,eAAe;AAAA,IACxB;AAGA,QAAI,KAAK,aAAa;AAClB,UAAI;AACA,aAAK,cAAc;AAAA,MACvB,SAAS,OAAO;AACZ,oBAAY;AAAA,UACR,sBAAsB,KAAK,WAAW;AAAA,UACtC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,gBAAY,IAAI,gCAAgC;AAAA,EACpD;AAAA,EAEA,MAAa,UAAU,MAAsC;AACzD,QAAI;AACA,YAAM,MAAM,IAAI,IAAI,KAAK,MAAM;AAC/B,UAAI,MAAM,QAAQ;AACd,YAAI,aAAa,OAAO,QAAQ,KAAK,KAAK,GAAG,CAAC;AAAA,MAClD;AAEA,YAAM,WAAW,MAAM,MAAM,IAAI,SAAS,CAAC;AAC3C,UAAI,CAAC,SAAS,IAAI;AACd,cAAM,IAAI,MAAM,yBAAyB,SAAS,UAAU,EAAE;AAAA,MAClE;AAEA,YAAM,OAAQ,MAAM,SAAS,KAAK;AAClC,aAAO,KAAK;AAAA,IAChB,SAAS,OAAO;AACZ,kBAAY,MAAM,wBAAwB,KAAK;AAC/C,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,MAAa,eAAe,QAAwC;AAChE,WAAO,KAAK,eAAe,YAAY;AACnC,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,MAAM,IAAI,MAAM,UAAU;AAC/D,UAAI,CAAC,SAAS,IAAI;AACd,cAAM,IAAI;AAAA,UACN,+BAA+B,SAAS,UAAU;AAAA,QACtD;AAAA,MACJ;AAEA,YAAM,OAAQ,MAAM,SAAS,KAAK;AAClC,aAAO,KAAK;AAAA,IAChB,CAAC;AAAA,EACL;AAAA,EAEA,MAAa,YACT,QACA,SACoB;AACpB,WAAO,KAAK,eAAe,YAAY;AACnC,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,MAAM,IAAI,MAAM,YAAY;AAAA,QAC7D,QAAQ;AAAA,QACR,SAAS,KAAK,eAAe;AAAA,QAC7B,MAAM,KAAK,UAAU;AAAA,UACjB;AAAA,UACA,QAAQ,KAAK;AAAA,QACjB,CAAC;AAAA,MACL,CAAC;AAED,UAAI,CAAC,SAAS,IAAI;AACd,cAAM,IAAI;AAAA,UACN,2BAA2B,SAAS,UAAU;AAAA,QAClD;AAAA,MACJ;AAEA,YAAM,OAAQ,MAAM,SAAS,KAAK;AAClC,aAAO,KAAK;AAAA,IAChB,CAAC;AAAA,EACL;AACJ;;;AC/LA;AAAA,EACI;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAKA;AAAA,EAEA;AAAA,EACA,eAAAC;AAAA,EACA;AAAA,OACG;AAIP,SAAS,sBAAsB,aAAqB,WAAmB;AACnE,SACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAMQ,WAAW;AAAA,cACb,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsBnB;AAEJ;AAEA,SAAS,4BAA4B,aAAqB,WAAmB;AACzE,SACI;AAAA;AAAA;AAAA;AAAA;AAAA,gBAKQ,WAAW;AAAA,cACb,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoCnB;AAEJ;AAEO,IAAM,oBAAN,MAAwB;AAAA,EACnB;AAAA,EACA;AAAA,EACA,wBAA6C,oBAAI,IAAI;AAAA,EACrD,oBAAyC,oBAAI,IAAI;AAAA,EACjD,iBAA6C,oBAAI,IAAI;AAAA,EACrD,iBAGJ,oBAAI,IAAI;AAAA,EACJ,eAAsC;AAAA,EAE9C,YAAY,QAA2B,SAAwB;AAC3D,SAAK,SAAS;AACd,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,MAAM,QAAQ;AACV,UAAM,eAAe;AAAA,MACjB,KAAK,QAAQ,WAAW,4BAA4B,KAAK;AAAA,IAC7D;AAEA,UAAM,yBAAyB,MAAM;AACjC,WAAK,mBAAmB;AACxB,WAAK,eAAe;AAAA,QAChB;AAAA,QACA,eAAe;AAAA,MACnB;AAAA,IACJ;AAEA,2BAAuB;AAAA,EAC3B;AAAA,EAEA,MAAM,OAAO;AACT,QAAI,KAAK,cAAc;AACnB,mBAAa,KAAK,YAAY;AAC9B,WAAK,eAAe;AAAA,IACxB;AAAA,EACJ;AAAA,EAEA,MAAc,mBACV,SACA,UACsB;AACtB,UAAM,SAAwB,CAAC;AAC/B,UAAM,kBAAkB;AAAA,MACpB,KAAK,QAAQ,WAAW,2BAA2B,KAAK;AAAA,IAC5D;AAGA,WAAO,KAAK,OAAO;AAGnB,UAAM,eAAe,SAChB,OAAO,CAAC,QAAQ,IAAI,WAAW,QAAQ,MAAM,EAC7C;AAAA,MACG,CAAC,GAAG,MACA,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAC9B,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,IACtC;AAGJ,eAAW,OAAO,cAAc;AAC5B,UAAI,OAAO,UAAU,gBAAiB;AACtC,UAAI,IAAI,OAAO,QAAQ,IAAI;AACvB,eAAO,QAAQ,GAAG;AAAA,MACtB;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,qBACJ,SACA,MACO;AACP,UAAM,YAAY,KAAK,OAAO,aAAa;AAG3C,QAAI,QAAQ,OAAO,aAAa,UAAU,UAAU;AAChD,aAAO;AAAA,IACX;AAGA,UAAM,cACF,KAAK,sBAAsB,IAAI,QAAQ,MAAM,KAAK;AACtD,QAAI,QAAQ,aAAa,aAAa;AAClC,aAAO;AAAA,IACX;AAGA,UAAM,mBACF,KAAK,kBAAkB,IAAI,QAAQ,MAAM,KAAK;AAClD,UAAM,0BAA0B;AAChC,QAAI,KAAK,IAAI,IAAI,mBAAmB,yBAAyB;AACzD,aAAO;AAAA,IACX;AAGA,UAAM,cAAc,QAAQ,QACvB,YAAY,EACZ,SAAS,GAAG,UAAU,SAAS,YAAY,CAAC,EAAE;AAGnD,UAAM,oBACF,KAAK,SACL,QAAQ,QAAQ,YAAY,EAAE,SAAS,KAAK,MAAM,YAAY,CAAC;AAGnE,WAAO,eAAe;AAAA,EAC1B;AAAA,EAEA,MAAc,qBAAqB;AAC/B,IAAAA,aAAY,IAAI,oCAAoC;AAEpD,QAAI;AACA,YAAM,cAAc,KAAK,QAAQ;AAAA,QAC7B;AAAA,MACJ;AACA,YAAM,QAAQ,MAAM,KAAK,OAAO,UAAU;AAE1C,iBAAW,QAAQ,OAAO;AAEtB,YAAI,eAAe,KAAK,OAAO,aAAa;AACxC;AAAA,QACJ;AAEA,cAAM,WAAW,MAAM,KAAK,OAAO,eAAe,KAAK,EAAE;AACzD,aAAK,eAAe,IAAI,KAAK,IAAI,QAAQ;AAGzC,cAAM,iBAAiB,SAClB,OAAO,CAAC,QAAQ,CAAC,KAAK,qBAAqB,KAAK,IAAI,CAAC,EACrD;AAAA,UACG,CAAC,GAAG,MACA,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAC9B,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,QACtC;AAEJ,YAAI,eAAe,SAAS,GAAG;AAC3B,gBAAM,gBAAgB,eAAe,CAAC;AACtC,gBAAM,KAAK,cAAc,eAAe,KAAK,KAAK;AAGlD,gBAAM,cAAc,KAAK,eAAe,IAAI,KAAK,EAAE,KAAK,CAAC;AACzD,sBAAY,KAAK;AAAA,YACb,SAAS;AAAA,YACT,UAAU;AAAA;AAAA,UACd,CAAC;AACD,eAAK,eAAe,IAAI,KAAK,IAAI,WAAW;AAG5C,cACI,cAAc,aACb,KAAK,sBAAsB,IAAI,KAAK,EAAE,KAAK,MAC9C;AACE,iBAAK,sBAAsB;AAAA,cACvB,KAAK;AAAA,cACL,cAAc;AAAA,YAClB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAEA,MAAAA,aAAY,IAAI,6CAA6C;AAAA,IACjE,SAAS,OAAO;AACZ,MAAAA,aAAY;AAAA,QACR;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAc,cAAc,SAAsB,WAAmB;AACjE,QAAI;AACA,YAAM,SAAS,aAAa,QAAQ,MAAM;AAC1C,YAAM,SAAS,aAAa,QAAQ,OAAO,QAAQ;AAGnD,YAAM,KAAK,QAAQ;AAAA,QACf;AAAA,QACA;AAAA,QACA,QAAQ,OAAO;AAAA,QACf,QAAQ,OAAO;AAAA,QACf;AAAA,MACJ;AAGA,YAAM,SAAS,MAAM,KAAK;AAAA,QACtB;AAAA,QACA,KAAK,eAAe,IAAI,QAAQ,MAAM,KAAK,CAAC;AAAA,MAChD;AAGA,YAAM,SAAiB;AAAA,QACnB,IAAI,aAAa,QAAQ,EAAE;AAAA,QAC3B;AAAA,QACA,SAAS,KAAK,QAAQ;AAAA,QACtB;AAAA,QACA,SAAS;AAAA,UACL,MAAM,QAAQ;AAAA,UACd,QAAQ;AAAA,UACR,QAAQ,OAAO,IAAI,CAAC,SAAS;AAAA,YACzB,MAAM,IAAI;AAAA,YACV,QAAQ,IAAI,OAAO;AAAA,YACnB,WAAW,IAAI;AAAA,UACnB,EAAE;AAAA,QACN;AAAA,QACA,WAAW,IAAI,KAAK,QAAQ,SAAS,EAAE,QAAQ;AAAA,QAC/C,WAAW,uBAAuB;AAAA,MACtC;AAGA,YAAM,WAAW,MAAM,KAAK,QAAQ,eAAe;AAAA,QAC/C,OAAO;AAAA,MACX;AACA,UAAI,UAAU;AACV,QAAAA,aAAY;AAAA,UACR,6BAA6B,QAAQ,EAAE;AAAA,QAC3C;AACA;AAAA,MACJ;AAGA,YAAM,KAAK,QAAQ,eAAe,aAAa,MAAM;AAGrD,UAAI,QAAQ,MAAM,KAAK,QAAQ,aAAa,MAAM;AAClD,cAAQ,MAAM,KAAK,QAAQ,yBAAyB,KAAK;AAGzD,YAAM,uBAAuB,eAAe;AAAA,QACxC;AAAA,QACA,UACI,KAAK,QAAQ,UAAU,WAAW,yBAClC,4BAA4B,QAAQ,QAAQ,SAAS;AAAA,MAC7D,CAAC;AAED,YAAM,gBAAgB,MAAM,sBAAsB;AAAA,QAC9C,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT,YAAY,WAAW;AAAA,MAC3B,CAAC;AAED,UAAI,kBAAkB,WAAW;AAC7B,QAAAA,aAAY;AAAA,UACR,6BAA6B,QAAQ,EAAE,KAAK,aAAa;AAAA,QAC7D;AACA;AAAA,MACJ;AAGA,YAAM,kBAAkB,eAAe;AAAA,QACnC;AAAA,QACA,UACI,KAAK,QAAQ,UAAU,WAAW,0BAClC,sBAAsB,QAAQ,QAAQ,SAAS;AAAA,MACvD,CAAC;AAED,YAAM,WAAW,MAAM,wBAAwB;AAAA,QAC3C,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT,YAAY,WAAW;AAAA,MAC3B,CAAC;AAED,UAAI,CAAC,YAAY,CAAC,SAAS,MAAM;AAC7B,QAAAA,aAAY,IAAI,uBAAuB;AACvC;AAAA,MACJ;AAGA,YAAM,WAA4B,OAAO,YAAqB;AAC1D,cAAM,cAAc,MAAM,KAAK,OAAO;AAAA,UAClC,QAAQ;AAAA,UACR,QAAQ;AAAA,QACZ;AAGA,aAAK,kBAAkB,IAAI,QAAQ,QAAQ,KAAK,IAAI,CAAC;AAGrD,cAAM,cACF,KAAK,eAAe,IAAI,QAAQ,MAAM,KAAK,CAAC;AAChD,cAAM,YAAY,YAAY,YAAY,SAAS,CAAC;AACpD,YAAI,aAAa,UAAU,QAAQ,OAAO,QAAQ,IAAI;AAClD,oBAAU,WAAW;AAAA,QACzB;AAEA,cAAM,iBAAyB;AAAA,UAC3B,IAAI,aAAa,YAAY,EAAE;AAAA,UAC/B,QAAQ,KAAK,QAAQ;AAAA,UACrB,SAAS,KAAK,QAAQ;AAAA,UACtB;AAAA,UACA,SAAS;AAAA,YACL,MAAM,YAAY;AAAA,YAClB,QAAQ;AAAA,YACR,QAAQ,QAAQ;AAAA,YAChB,QAAQ,OAAO,IAAI,CAAC,SAAS;AAAA,cACzB,MAAM,IAAI;AAAA,cACV,QAAQ,IAAI,OAAO;AAAA,cACnB,WAAW,IAAI;AAAA,YACnB,EAAE;AAAA,UACN;AAAA,UACA,WAAW,IAAI,KAAK,YAAY,SAAS,EAAE,QAAQ;AAAA,UACnD,WAAW,uBAAuB;AAAA,QACtC;AAEA,cAAM,KAAK,QAAQ,eAAe,aAAa,cAAc;AAC7D,eAAO,CAAC,cAAc;AAAA,MAC1B;AAGA,YAAM,mBAAmB,MAAM,SAAS,QAAQ;AAChD,cAAQ,MAAM,KAAK,QAAQ,yBAAyB,KAAK;AACzD,YAAM,KAAK,QAAQ;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AACA,YAAM,KAAK,QAAQ,SAAS,QAAQ,OAAO,IAAI;AAAA,IACnD,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,2BAA2B,KAAK;AAAA,IACtD;AAAA,EACJ;AACJ;;;AC3aA,SAAwB,eAAAC,oBAAmB;AAE3C,eAAsB,0BAClB,SACa;AACb,QAAM,SAAS,QAAQ,WAAW,sBAAsB;AACxD,QAAM,SAAS,QAAQ,WAAW,sBAAsB;AAExD,MAAI,CAAC,QAAQ;AACT,IAAAA,aAAY;AAAA,MACR;AAAA,IACJ;AACA,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AAEA,MAAI,CAAC,QAAQ;AACT,IAAAA,aAAY;AAAA,MACR;AAAA,IACJ;AACA,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AAGA,MAAI;AACA,QAAI,IAAI,MAAM;AAAA,EAClB,SAAS,OAAO;AACZ,IAAAA,aAAY;AAAA,MACR,wCAAwC,MAAM;AAAA,IAClD;AACA,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACzD;AAGA,QAAM,WACF,QAAQ,WAAW,uBAAuB,KAC1C,SAAS,QAAQ,OAAO;AAC5B,QAAM,cACF,QAAQ,WAAW,2BAA2B,KAAK;AACvD,QAAM,eAAe;AAAA,IACjB,QAAQ,WAAW,4BAA4B,KAAK;AAAA,EACxD;AAEA,MAAI,MAAM,YAAY,KAAK,eAAe,GAAG;AACzC,IAAAA,aAAY;AAAA,MACR;AAAA,IACJ;AACA,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACxD;AAEA,EAAAA,aAAY,IAAI,mDAAmD;AACnE,EAAAA,aAAY,IAAI,YAAY,MAAM,EAAE;AACpC,EAAAA,aAAY,IAAI,aAAa,QAAQ,EAAE;AACvC,EAAAA,aAAY,IAAI,iBAAiB,WAAW,EAAE;AAC9C,EAAAA,aAAY,IAAI,kBAAkB,YAAY,GAAG;AACrD;;;ACFO,IAAK,YAAL,kBAAKC,eAAL;AACH,EAAAA,WAAA,qBAAkB;AAClB,EAAAA,WAAA,kBAAe;AACf,EAAAA,WAAA,kBAAe;AACf,EAAAA,WAAA,iBAAc;AACd,EAAAA,WAAA,eAAY;AALJ,SAAAA;AAAA,GAAA;;;AJ9CL,IAAM,6BAAqC;AAAA,EAC9C,MAAM,MAAM,SAAwB;AAChC,QAAI;AAEA,YAAM,0BAA0B,OAAO;AAEvC,YAAM,SAAS,QAAQ,WAAW,sBAAsB;AACxD,YAAM,SAAS,QAAQ,WAAW,sBAAsB;AAExD,UAAI,CAAC,UAAU,CAAC,QAAQ;AACpB,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,SAA4B;AAAA,QAC9B;AAAA,QACA;AAAA,QACA,UACI,QAAQ,WAAW,uBAAuB,KAC1C,SAAS,QAAQ,OAAO;AAAA,QAC5B,OAAO,QAAQ;AAAA,QACf,aACI,QAAQ,WAAW,2BAA2B,KAC9C;AAAA,MACR;AAEA,MAAAC,aAAY,IAAI,iCAAiC;AAGjD,YAAM,SAAS,IAAI,kBAAkB,SAAS,MAAM;AACpD,YAAM,OAAO,MAAM;AAGnB,YAAM,oBAAoB,IAAI,kBAAkB,QAAQ,OAAO;AAC/D,YAAM,kBAAkB,MAAM;AAE9B,MAAAA,aAAY;AAAA,QACR,iEAA4D,QAAQ,UAAU,IAAI;AAAA,MACtF;AAEA,aAAO,EAAE,QAAQ,kBAAkB;AAAA,IACvC,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,wCAAwC,KAAK;AAC/D,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,MAAM,KAAK,SAAwB;AAC/B,QAAI;AACA,MAAAA,aAAY,KAAK,iCAAiC;AAGlD,YAAM,UAAW,QAAgB,SAAS;AAAA,QACtC,CAAC,MACG,aAAa,qBACb,aAAa;AAAA,MACrB;AAEA,iBAAW,UAAU,SAAS;AAC1B,cAAM,OAAO,KAAK;AAAA,MACtB;AAEA,MAAAA,aAAY,QAAQ,0CAA0C;AAAA,IAClE,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,uCAAuC,KAAK;AAC9D,YAAM;AAAA,IACV;AAAA,EACJ;AACJ;AAEO,IAAM,oBAA4B;AAAA,EACrC,MAAM;AAAA,EACN,aACI;AAAA,EACJ,SAAS,CAAC;AAAA;AAAA,EACV,YAAY,CAAC;AAAA;AAAA,EACb,WAAW,CAAC;AAAA;AAAA,EACZ,SAAS,CAAC,0BAA0B;AACxC;AAEA,IAAO,gBAAQ;","names":["elizaLogger","elizaLogger","elizaLogger","RoomEvent","elizaLogger"]}