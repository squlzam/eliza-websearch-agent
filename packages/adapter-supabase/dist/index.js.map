{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { createClient, type SupabaseClient } from \"@supabase/supabase-js\";\nimport {\n    type Memory,\n    type Goal,\n    type Relationship,\n    Actor,\n    GoalStatus,\n    Account,\n    type UUID,\n    Participant,\n    Room,\n} from \"@elizaos/core\";\nimport { DatabaseAdapter } from \"@elizaos/core\";\nimport { v4 as uuid } from \"uuid\";\nexport class SupabaseDatabaseAdapter extends DatabaseAdapter {\n    async getRoom(roomId: UUID): Promise<UUID | null> {\n        const { data, error } = await this.supabase\n            .from(\"rooms\")\n            .select(\"id\")\n            .eq(\"id\", roomId)\n            .single();\n\n        if (error) {\n            throw new Error(`Error getting room: ${error.message}`);\n        }\n\n        return data ? (data.id as UUID) : null;\n    }\n\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"*\")\n            .eq(\"userId\", userId);\n\n        if (error) {\n            throw new Error(\n                `Error getting participants for account: ${error.message}`\n            );\n        }\n\n        return data as Participant[];\n    }\n\n    async getParticipantUserState(\n        roomId: UUID,\n        userId: UUID\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"userState\")\n            .eq(\"roomId\", roomId)\n            .eq(\"userId\", userId)\n            .single();\n\n        if (error) {\n            console.error(\"Error getting participant user state:\", error);\n            return null;\n        }\n\n        return data?.userState as \"FOLLOWED\" | \"MUTED\" | null;\n    }\n\n    async setParticipantUserState(\n        roomId: UUID,\n        userId: UUID,\n        state: \"FOLLOWED\" | \"MUTED\" | null\n    ): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"participants\")\n            .update({ userState: state })\n            .eq(\"roomId\", roomId)\n            .eq(\"userId\", userId);\n\n        if (error) {\n            console.error(\"Error setting participant user state:\", error);\n            throw new Error(\"Failed to set participant user state\");\n        }\n    }\n\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"userId\")\n            .eq(\"roomId\", roomId);\n\n        if (error) {\n            throw new Error(\n                `Error getting participants for room: ${error.message}`\n            );\n        }\n\n        return data.map((row) => row.userId as UUID);\n    }\n\n    supabase: SupabaseClient;\n\n    constructor(supabaseUrl: string, supabaseKey: string) {\n        super();\n        this.supabase = createClient(supabaseUrl, supabaseKey);\n    }\n\n    async init() {\n        // noop\n    }\n\n    async close() {\n        // noop\n    }\n\n    async getMemoriesByRoomIds(params: {\n        roomIds: UUID[];\n        agentId?: UUID;\n        tableName: string;\n    }): Promise<Memory[]> {\n        let query = this.supabase\n            .from(params.tableName)\n            .select(\"*\")\n            .in(\"roomId\", params.roomIds);\n\n        if (params.agentId) {\n            query = query.eq(\"agentId\", params.agentId);\n        }\n\n        const { data, error } = await query;\n\n        if (error) {\n            console.error(\"Error retrieving memories by room IDs:\", error);\n            return [];\n        }\n\n        // map createdAt to Date\n        const memories = data.map((memory) => ({\n            ...memory,\n        }));\n\n        return memories as Memory[];\n    }\n\n    async getAccountById(userId: UUID): Promise<Account | null> {\n        const { data, error } = await this.supabase\n            .from(\"accounts\")\n            .select(\"*\")\n            .eq(\"id\", userId);\n        if (error) {\n            throw new Error(error.message);\n        }\n        return (data?.[0] as Account) || null;\n    }\n\n    async createAccount(account: Account): Promise<boolean> {\n        const { error } = await this.supabase\n            .from(\"accounts\")\n            .upsert([account]);\n        if (error) {\n            console.error(error.message);\n            return false;\n        }\n        return true;\n    }\n\n    async getActorDetails(params: { roomId: UUID }): Promise<Actor[]> {\n        try {\n            const response = await this.supabase\n                .from(\"rooms\")\n                .select(\n                    `\n          participants:participants(\n            account:accounts(id, name, username, details)\n          )\n      `\n                )\n                .eq(\"id\", params.roomId);\n\n            if (response.error) {\n                console.error(\"Error!\" + response.error);\n                return [];\n            }\n            const { data } = response;\n\n            return data\n                .map((room) =>\n                    room.participants.map((participant) => {\n                        const user = participant.account as unknown as Actor;\n                        return {\n                            name: user?.name,\n                            details: user?.details,\n                            id: user?.id,\n                            username: user?.username,\n                        };\n                    })\n                )\n                .flat();\n        } catch (error) {\n            console.error(\"error\", error);\n            throw error;\n        }\n    }\n\n    async searchMemories(params: {\n        tableName: string;\n        roomId: UUID;\n        embedding: number[];\n        match_threshold: number;\n        match_count: number;\n        unique: boolean;\n    }): Promise<Memory[]> {\n        const result = await this.supabase.rpc(\"search_memories\", {\n            query_table_name: params.tableName,\n            query_roomId: params.roomId,\n            query_embedding: params.embedding,\n            query_match_threshold: params.match_threshold,\n            query_match_count: params.match_count,\n            query_unique: params.unique,\n        });\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n        return result.data.map((memory) => ({\n            ...memory,\n        }));\n    }\n\n    async getCachedEmbeddings(opts: {\n        query_table_name: string;\n        query_threshold: number;\n        query_input: string;\n        query_field_name: string;\n        query_field_sub_name: string;\n        query_match_count: number;\n    }): Promise<\n        {\n            embedding: number[];\n            levenshtein_score: number;\n        }[]\n    > {\n        const result = await this.supabase.rpc(\"get_embedding_list\", opts);\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n        return result.data;\n    }\n\n    async updateGoalStatus(params: {\n        goalId: UUID;\n        status: GoalStatus;\n    }): Promise<void> {\n        await this.supabase\n            .from(\"goals\")\n            .update({ status: params.status })\n            .match({ id: params.goalId });\n    }\n\n    async log(params: {\n        body: { [key: string]: unknown };\n        userId: UUID;\n        roomId: UUID;\n        type: string;\n    }): Promise<void> {\n        const { error } = await this.supabase.from(\"logs\").insert({\n            body: params.body,\n            userId: params.userId,\n            roomId: params.roomId,\n            type: params.type,\n        });\n\n        if (error) {\n            console.error(\"Error inserting log:\", error);\n            throw new Error(error.message);\n        }\n    }\n\n    async getMemories(params: {\n        roomId: UUID;\n        count?: number;\n        unique?: boolean;\n        tableName: string;\n        agentId?: UUID;\n        start?: number;\n        end?: number;\n    }): Promise<Memory[]> {\n        const query = this.supabase\n            .from(params.tableName)\n            .select(\"*\")\n            .eq(\"roomId\", params.roomId);\n\n        if (params.start) {\n            query.gte(\"createdAt\", params.start);\n        }\n\n        if (params.end) {\n            query.lte(\"createdAt\", params.end);\n        }\n\n        if (params.unique) {\n            query.eq(\"unique\", true);\n        }\n\n        if (params.agentId) {\n            query.eq(\"agentId\", params.agentId);\n        }\n\n        query.order(\"createdAt\", { ascending: false });\n\n        if (params.count) {\n            query.limit(params.count);\n        }\n\n        const { data, error } = await query;\n\n        if (error) {\n            throw new Error(`Error retrieving memories: ${error.message}`);\n        }\n\n        return data as Memory[];\n    }\n\n    async searchMemoriesByEmbedding(\n        embedding: number[],\n        params: {\n            match_threshold?: number;\n            count?: number;\n            roomId?: UUID;\n            agentId?: UUID;\n            unique?: boolean;\n            tableName: string;\n        }\n    ): Promise<Memory[]> {\n        const queryParams = {\n            query_table_name: params.tableName,\n            query_roomId: params.roomId,\n            query_embedding: embedding,\n            query_match_threshold: params.match_threshold,\n            query_match_count: params.count,\n            query_unique: !!params.unique,\n        };\n        if (params.agentId) {\n            (queryParams as any).query_agentId = params.agentId;\n        }\n\n        const result = await this.supabase.rpc(\"search_memories\", queryParams);\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n        return result.data.map((memory) => ({\n            ...memory,\n        }));\n    }\n\n    async getMemoryById(memoryId: UUID): Promise<Memory | null> {\n        const { data, error } = await this.supabase\n            .from(\"memories\")\n            .select(\"*\")\n            .eq(\"id\", memoryId)\n            .single();\n\n        if (error) {\n            console.error(\"Error retrieving memory by ID:\", error);\n            return null;\n        }\n\n        return data as Memory;\n    }\n\n    async createMemory(\n        memory: Memory,\n        tableName: string,\n        unique = false\n    ): Promise<void> {\n        const createdAt = memory.createdAt ?? Date.now();\n        if (unique) {\n            const opts = {\n                // TODO: Add ID option, optionally\n                query_table_name: tableName,\n                query_userId: memory.userId,\n                query_content: memory.content.text,\n                query_roomId: memory.roomId,\n                query_embedding: memory.embedding,\n                query_createdAt: createdAt,\n                similarity_threshold: 0.95,\n            };\n\n            const result = await this.supabase.rpc(\n                \"check_similarity_and_insert\",\n                opts\n            );\n\n            if (result.error) {\n                throw new Error(JSON.stringify(result.error));\n            }\n        } else {\n            const result = await this.supabase\n                .from(\"memories\")\n                .insert({ ...memory, createdAt, type: tableName });\n            const { error } = result;\n            if (error) {\n                throw new Error(JSON.stringify(error));\n            }\n        }\n    }\n\n    async removeMemory(memoryId: UUID): Promise<void> {\n        const result = await this.supabase\n            .from(\"memories\")\n            .delete()\n            .eq(\"id\", memoryId);\n        const { error } = result;\n        if (error) {\n            throw new Error(JSON.stringify(error));\n        }\n    }\n\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\n        const result = await this.supabase.rpc(\"remove_memories\", {\n            query_table_name: tableName,\n            query_roomId: roomId,\n        });\n\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n    }\n\n    async countMemories(\n        roomId: UUID,\n        unique = true,\n        tableName: string\n    ): Promise<number> {\n        if (!tableName) {\n            throw new Error(\"tableName is required\");\n        }\n        const query = {\n            query_table_name: tableName,\n            query_roomId: roomId,\n            query_unique: !!unique,\n        };\n        const result = await this.supabase.rpc(\"count_memories\", query);\n\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n\n        return result.data;\n    }\n\n    async getGoals(params: {\n        roomId: UUID;\n        userId?: UUID | null;\n        onlyInProgress?: boolean;\n        count?: number;\n    }): Promise<Goal[]> {\n        const opts = {\n            query_roomId: params.roomId,\n            query_userId: params.userId,\n            only_in_progress: params.onlyInProgress,\n            row_count: params.count,\n        };\n\n        const { data: goals, error } = await this.supabase.rpc(\n            \"get_goals\",\n            opts\n        );\n\n        if (error) {\n            throw new Error(error.message);\n        }\n\n        return goals;\n    }\n\n    async updateGoal(goal: Goal): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"goals\")\n            .update(goal)\n            .match({ id: goal.id });\n        if (error) {\n            throw new Error(`Error creating goal: ${error.message}`);\n        }\n    }\n\n    async createGoal(goal: Goal): Promise<void> {\n        const { error } = await this.supabase.from(\"goals\").insert(goal);\n        if (error) {\n            throw new Error(`Error creating goal: ${error.message}`);\n        }\n    }\n\n    async removeGoal(goalId: UUID): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"goals\")\n            .delete()\n            .eq(\"id\", goalId);\n        if (error) {\n            throw new Error(`Error removing goal: ${error.message}`);\n        }\n    }\n\n    async removeAllGoals(roomId: UUID): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"goals\")\n            .delete()\n            .eq(\"roomId\", roomId);\n        if (error) {\n            throw new Error(`Error removing goals: ${error.message}`);\n        }\n    }\n\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"roomId\")\n            .eq(\"userId\", userId);\n\n        if (error) {\n            throw new Error(\n                `Error getting rooms by participant: ${error.message}`\n            );\n        }\n\n        return data.map((row) => row.roomId as UUID);\n    }\n\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"roomId\")\n            .in(\"userId\", userIds);\n\n        if (error) {\n            throw new Error(\n                `Error getting rooms by participants: ${error.message}`\n            );\n        }\n\n        return [...new Set(data.map((row) => row.roomId as UUID))] as UUID[];\n    }\n\n    async createRoom(roomId?: UUID): Promise<UUID> {\n        roomId = roomId ?? (uuid() as UUID);\n        const { data, error } = await this.supabase.rpc(\"create_room\", {\n            roomId,\n        });\n\n        if (error) {\n            throw new Error(`Error creating room: ${error.message}`);\n        }\n\n        if (!data || data.length === 0) {\n            throw new Error(\"No data returned from room creation\");\n        }\n\n        return data[0].id as UUID;\n    }\n\n    async removeRoom(roomId: UUID): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"rooms\")\n            .delete()\n            .eq(\"id\", roomId);\n\n        if (error) {\n            throw new Error(`Error removing room: ${error.message}`);\n        }\n    }\n\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        const { error } = await this.supabase\n            .from(\"participants\")\n            .insert({ userId: userId, roomId: roomId });\n\n        if (error) {\n            console.error(`Error adding participant: ${error.message}`);\n            return false;\n        }\n        return true;\n    }\n\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        const { error } = await this.supabase\n            .from(\"participants\")\n            .delete()\n            .eq(\"userId\", userId)\n            .eq(\"roomId\", roomId);\n\n        if (error) {\n            console.error(`Error removing participant: ${error.message}`);\n            return false;\n        }\n        return true;\n    }\n\n    async createRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<boolean> {\n        const allRoomData = await this.getRoomsForParticipants([\n            params.userA,\n            params.userB,\n        ]);\n\n        let roomId: UUID;\n\n        if (!allRoomData || allRoomData.length === 0) {\n            // If no existing room is found, create a new room\n            const { data: newRoomData, error: roomsError } = await this.supabase\n                .from(\"rooms\")\n                .insert({})\n                .single();\n\n            if (roomsError) {\n                throw new Error(\"Room creation error: \" + roomsError.message);\n            }\n\n            roomId = (newRoomData as Room)?.id as UUID;\n        } else {\n            // If an existing room is found, use the first room's ID\n            roomId = allRoomData[0];\n        }\n\n        const { error: participantsError } = await this.supabase\n            .from(\"participants\")\n            .insert([\n                { userId: params.userA, roomId },\n                { userId: params.userB, roomId },\n            ]);\n\n        if (participantsError) {\n            throw new Error(\n                \"Participants creation error: \" + participantsError.message\n            );\n        }\n\n        // Create or update the relationship between the two users\n        const { error: relationshipError } = await this.supabase\n            .from(\"relationships\")\n            .upsert({\n                userA: params.userA,\n                userB: params.userB,\n                userId: params.userA,\n                status: \"FRIENDS\",\n            })\n            .eq(\"userA\", params.userA)\n            .eq(\"userB\", params.userB);\n\n        if (relationshipError) {\n            throw new Error(\n                \"Relationship creation error: \" + relationshipError.message\n            );\n        }\n\n        return true;\n    }\n\n    async getRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<Relationship | null> {\n        const { data, error } = await this.supabase.rpc(\"get_relationship\", {\n            usera: params.userA,\n            userb: params.userB,\n        });\n\n        if (error) {\n            throw new Error(error.message);\n        }\n\n        return data[0];\n    }\n\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\n        const { data, error } = await this.supabase\n            .from(\"relationships\")\n            .select(\"*\")\n            .or(`userA.eq.${params.userId},userB.eq.${params.userId}`)\n            .eq(\"status\", \"FRIENDS\");\n\n        if (error) {\n            throw new Error(error.message);\n        }\n\n        return data as Relationship[];\n    }\n}\n"],"mappings":"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","names":[]}