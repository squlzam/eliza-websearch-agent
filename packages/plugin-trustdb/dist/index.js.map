{"version":3,"sources":["../src/adapters/trustScoreDatabase.ts"],"sourcesContent":["import { Database } from \"better-sqlite3\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport interface Recommender {\n    id: string; // UUID\n    address: string;\n    solanaPubkey?: string;\n    telegramId?: string;\n    discordId?: string;\n    twitterId?: string;\n    ip?: string;\n}\n\nexport interface RecommenderMetrics {\n    recommenderId: string;\n    trustScore: number;\n    totalRecommendations: number;\n    successfulRecs: number;\n    avgTokenPerformance: number;\n    riskScore: number;\n    consistencyScore: number;\n    virtualConfidence: number;\n    lastActiveDate: Date;\n    trustDecay: number;\n    lastUpdated: Date;\n}\n\nexport interface TokenPerformance {\n    tokenAddress: string;\n    symbol: string;\n    priceChange24h: number;\n    volumeChange24h: number;\n    trade_24h_change: number;\n    liquidity: number;\n    liquidityChange24h: number;\n    holderChange24h: number;\n    rugPull: boolean;\n    isScam: boolean;\n    marketCapChange24h: number;\n    sustainedGrowth: boolean;\n    rapidDump: boolean;\n    suspiciousVolume: boolean;\n    validationTrust: number;\n    balance: number;\n    initialMarketCap: number;\n    lastUpdated: Date;\n}\n\nexport interface TokenRecommendation {\n    id: string; // UUID\n    recommenderId: string;\n    tokenAddress: string;\n    timestamp: Date;\n    initialMarketCap?: number;\n    initialLiquidity?: number;\n    initialPrice?: number;\n}\nexport interface RecommenderMetricsHistory {\n    historyId: string; // UUID\n    recommenderId: string;\n    trustScore: number;\n    totalRecommendations: number;\n    successfulRecs: number;\n    avgTokenPerformance: number;\n    riskScore: number;\n    consistencyScore: number;\n    virtualConfidence: number;\n    trustDecay: number;\n    recordedAt: Date;\n}\n\nexport interface TradePerformance {\n    token_address: string;\n    recommender_id: string;\n    buy_price: number;\n    sell_price: number;\n    buy_timeStamp: string;\n    sell_timeStamp: string;\n    buy_amount: number;\n    sell_amount: number;\n    buy_sol: number;\n    received_sol: number;\n    buy_value_usd: number;\n    sell_value_usd: number;\n    profit_usd: number;\n    profit_percent: number;\n    buy_market_cap: number;\n    sell_market_cap: number;\n    market_cap_change: number;\n    buy_liquidity: number;\n    sell_liquidity: number;\n    liquidity_change: number;\n    last_updated: string;\n    rapidDump: boolean;\n}\n\ninterface RecommenderMetricsRow {\n    recommender_id: string;\n    trust_score: number;\n    total_recommendations: number;\n    successful_recs: number;\n    avg_token_performance: number;\n    risk_score: number;\n    consistency_score: number;\n    virtual_confidence: number;\n    last_active_date: Date;\n    trust_decay: number;\n    last_updated: string;\n}\n\ninterface TokenPerformanceRow {\n    token_address: string;\n    symbol: string;\n    price_change_24h: number;\n    volume_change_24h: number;\n    trade_24h_change: number;\n    liquidity: number;\n    liquidity_change_24h: number;\n    holder_change_24h: number;\n    rug_pull: number;\n    is_scam: number;\n    market_cap_change24h: number;\n    sustained_growth: number;\n    rapid_dump: number;\n    suspicious_volume: number;\n    validation_trust: number;\n    balance: number;\n    initial_market_cap: number;\n    last_updated: string;\n}\n\ninterface Transaction {\n    tokenAddress: string;\n    transactionHash: string;\n    type: \"buy\" | \"sell\";\n    amount: number;\n    price: number;\n    isSimulation: boolean;\n    timestamp: string;\n}\n\nexport class TrustScoreDatabase {\n    private db: Database;\n\n    constructor(db: Database) {\n        this.db = db;\n        // load(db);\n        // check if the tables exist, if not create them\n        const tables = this.db\n            .prepare(\n                \"SELECT name FROM sqlite_master WHERE type='table' AND name IN ('recommenders', 'recommender_metrics', 'token_performance', 'token_recommendations', 'recommender_metrics_history');\"\n            )\n            .all();\n        if (tables.length !== 5) {\n            this.initializeSchema();\n        }\n    }\n\n    private initializeSchema() {\n        // Enable Foreign Key Support\n        this.db.exec(`PRAGMA foreign_keys = ON;`);\n\n        // Create Recommenders Table\n        this.db.exec(`\n            CREATE TABLE IF NOT EXISTS recommenders (\n                id TEXT PRIMARY KEY,\n                address TEXT UNIQUE NOT NULL,\n                solana_pubkey TEXT UNIQUE,\n                telegram_id TEXT UNIQUE,\n                discord_id TEXT UNIQUE,\n                twitter_id TEXT UNIQUE,\n                ip TEXT\n            );\n        `);\n\n        // Create RecommenderMetrics Table\n        this.db.exec(`\n            CREATE TABLE IF NOT EXISTS recommender_metrics (\n                recommender_id TEXT PRIMARY KEY,\n                trust_score REAL DEFAULT 0,\n                total_recommendations INTEGER DEFAULT 0,\n                successful_recs INTEGER DEFAULT 0,\n                avg_token_performance REAL DEFAULT 0,\n                risk_score REAL DEFAULT 0,\n                consistency_score REAL DEFAULT 0,\n                virtual_confidence REAL DEFAULT 0,\n                last_active_date DATETIME DEFAULT CURRENT_TIMESTAMP,\n                trust_decay REAL DEFAULT 0,\n                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (recommender_id) REFERENCES recommenders(id) ON DELETE CASCADE\n            );\n        `);\n\n        // Create TokenPerformance Table\n        this.db.exec(`\n            CREATE TABLE IF NOT EXISTS token_performance (\n                token_address TEXT PRIMARY KEY,\n                symbol TEXT,\n                price_change_24h REAL,\n                volume_change_24h REAL,\n                trade_24h_change REAL,\n                liquidity REAL,\n                liquidity_change_24h REAL,\n                holder_change_24h REAL,\n                rug_pull BOOLEAN DEFAULT FALSE,\n                is_scam BOOLEAN DEFAULT FALSE,\n                market_cap_change24h REAL,\n                sustained_growth BOOLEAN DEFAULT FALSE,\n                rapid_dump BOOLEAN DEFAULT FALSE,\n                suspicious_volume BOOLEAN DEFAULT FALSE,\n                validation_trust REAL DEFAULT 0,\n                balance REAL DEFAULT 0,\n                initial_market_cap REAL DEFAULT 0,\n                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP\n            );\n        `);\n\n        // Create TokenRecommendations Table\n        this.db.exec(`\n            CREATE TABLE IF NOT EXISTS token_recommendations (\n                id TEXT PRIMARY KEY,\n                recommender_id TEXT NOT NULL,\n                token_address TEXT NOT NULL,\n                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n                initial_market_cap REAL,\n                initial_liquidity REAL,\n                initial_price REAL,\n                FOREIGN KEY (recommender_id) REFERENCES recommenders(id) ON DELETE CASCADE,\n                FOREIGN KEY (token_address) REFERENCES token_performance(token_address) ON DELETE CASCADE\n            );\n        `);\n\n        // ----- Create RecommenderMetricsHistory Table -----\n        this.db.exec(`\n         CREATE TABLE IF NOT EXISTS recommender_metrics_history (\n             history_id TEXT PRIMARY KEY,\n             recommender_id TEXT NOT NULL,\n             trust_score REAL,\n             total_recommendations INTEGER,\n             successful_recs INTEGER,\n             avg_token_performance REAL,\n             risk_score REAL,\n             consistency_score REAL,\n             virtual_confidence REAL DEFAULT 0,\n             recorded_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n             FOREIGN KEY (recommender_id) REFERENCES recommenders(id) ON DELETE CASCADE\n         );\n     `);\n\n        // ----- Create TradePerformance Tables -----\n        this.db.exec(`\n        CREATE TABLE IF NOT EXISTS trade (\n            token_address TEXT NOT NULL,\n            recommender_id TEXT NOT NULL,\n            sell_recommender_id TEXT,\n            buy_price REAL NOT NULL,\n            sell_price REAL,\n            buy_timeStamp TEXT NOT NULL,\n            sell_timeStamp TEXT,\n            buy_amount REAL NOT NULL,\n            sell_amount REAL,\n            buy_sol REAL NOT NULL,\n            received_sol REAL,\n            buy_value_usd REAL NOT NULL,\n            sell_value_usd REAL,\n            profit_usd REAL,\n            profit_percent REAL,\n            buy_market_cap REAL NOT NULL,\n            sell_market_cap REAL,\n            market_cap_change REAL,\n            buy_liquidity REAL NOT NULL,\n            sell_liquidity REAL,\n            liquidity_change REAL,\n            last_updated TEXT DEFAULT (datetime('now')),\n            rapidDump BOOLEAN DEFAULT FALSE,\n            PRIMARY KEY (token_address, recommender_id, buy_timeStamp),\n            FOREIGN KEY (token_address) REFERENCES token_performance(token_address) ON DELETE CASCADE,\n            FOREIGN KEY (recommender_id) REFERENCES recommenders(id) ON DELETE CASCADE\n        );\n    `);\n        // create trade simulation table\n        this.db.exec(`\n      CREATE TABLE IF NOT EXISTS simulation_trade (\n          token_address TEXT NOT NULL,\n          recommender_id TEXT NOT NULL,\n          buy_price REAL NOT NULL,\n          sell_price REAL,\n          buy_timeStamp TEXT NOT NULL,\n          sell_timeStamp TEXT,\n          buy_amount REAL NOT NULL,\n          sell_amount REAL,\n          buy_sol REAL NOT NULL,\n          received_sol REAL,\n          buy_value_usd REAL NOT NULL,\n          sell_value_usd REAL,\n          profit_usd REAL,\n          profit_percent REAL,\n          buy_market_cap REAL NOT NULL,\n          sell_market_cap REAL,\n          market_cap_change REAL,\n          buy_liquidity REAL NOT NULL,\n          sell_liquidity REAL,\n          liquidity_change REAL,\n          last_updated TEXT DEFAULT (datetime('now')),\n          rapidDump BOOLEAN DEFAULT FALSE,\n          PRIMARY KEY (token_address, recommender_id, buy_timeStamp),\n          FOREIGN KEY (token_address) REFERENCES token_performance(token_address) ON DELETE CASCADE,\n          FOREIGN KEY (recommender_id) REFERENCES recommenders(id) ON DELETE CASCADE\n      );\n  `);\n\n        // create transactions table\n        this.db.exec(`\n        CREATE TABLE IF NOT EXISTS transactions (\n            token_address TEXT NOT NULL,\n            transaction_hash TEXT PRIMARY KEY,\n            type TEXT NOT NULL,\n            amount REAL NOT NULL,\n            price REAL NOT NULL,\n            timestamp TEXT NOT NULL,\n            is_simulation BOOLEAN DEFAULT FALSE,\n            FOREIGN KEY (token_address) REFERENCES token_performance(token_address) ON DELETE CASCADE\n        );\n    `);\n    }\n\n    /**\n     * Adds a new recommender to the database.\n     * @param recommender Recommender object\n     * @returns boolean indicating success\n     */\n    addRecommender(recommender: Recommender): string | null {\n        const sql = `\n            INSERT INTO recommenders (id, address, solana_pubkey, telegram_id, discord_id, twitter_id, ip)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n            ON CONFLICT(address) DO NOTHING;\n        `;\n        try {\n            const id = recommender.id || uuidv4();\n            const result = this.db\n                .prepare(sql)\n                .run(\n                    id,\n                    recommender.address,\n                    recommender.solanaPubkey || null,\n                    recommender.telegramId || null,\n                    recommender.discordId || null,\n                    recommender.twitterId || null,\n                    recommender.ip || null\n                );\n            return result.changes > 0 ? id : null;\n        } catch (error) {\n            console.error(\"Error adding recommender:\", error);\n            return null;\n        }\n    }\n\n    /**\n     * Retrieves a recommender by any identifier.\n     * @param identifier Any of the recommender's identifiers\n     * @returns Recommender object or null\n     */\n    getRecommender(identifier: string): Recommender | null {\n        const sql = `\n            SELECT * FROM recommenders\n            WHERE id = ? OR address = ? OR solana_pubkey = ? OR telegram_id = ? OR discord_id = ? OR twitter_id = ?;\n        `;\n        const recommender = this.db\n            .prepare(sql)\n            .get(\n                identifier,\n                identifier,\n                identifier,\n                identifier,\n                identifier,\n                identifier\n            ) as Recommender | undefined;\n        return recommender || null;\n    }\n\n    /**\n     * Retrieves an existing recommender or creates a new one if not found.\n     * Also initializes metrics for the recommender if they haven't been initialized yet.\n     * @param recommender Recommender object containing at least one identifier\n     * @returns Recommender object with all details, or null if failed\n     */\n    getOrCreateRecommender(recommender: Recommender): Recommender | null {\n        try {\n            // Begin a transaction\n            const transaction = this.db.transaction(() => {\n                // Attempt to retrieve the recommender\n                const existingRecommender = this.getRecommender(\n                    recommender.address\n                );\n                if (existingRecommender) {\n                    // Recommender exists, ensure metrics are initialized\n                    this.initializeRecommenderMetrics(existingRecommender.id!);\n                    return existingRecommender;\n                }\n\n                // Recommender does not exist, create a new one\n                const newRecommenderId = this.addRecommender(recommender);\n                if (!newRecommenderId) {\n                    throw new Error(\"Failed to add new recommender.\");\n                }\n\n                // Initialize metrics for the new recommender\n                const metricsInitialized =\n                    this.initializeRecommenderMetrics(newRecommenderId);\n                if (!metricsInitialized) {\n                    throw new Error(\n                        \"Failed to initialize recommender metrics.\"\n                    );\n                }\n\n                // Retrieve and return the newly created recommender\n                const newRecommender = this.getRecommender(newRecommenderId);\n                if (!newRecommender) {\n                    throw new Error(\n                        \"Failed to retrieve the newly created recommender.\"\n                    );\n                }\n\n                return newRecommender;\n            });\n\n            // Execute the transaction and return the recommender\n            const recommenderResult = transaction();\n            return recommenderResult;\n        } catch (error) {\n            console.error(\"Error in getOrCreateRecommender:\", error);\n            return null;\n        }\n    }\n\n    /**\n     * Retrieves an existing recommender or creates a new one if not found.\n     * Also initializes metrics for the recommender if they haven't been initialized yet.\n     * @param discordId Discord ID of the recommender\n     * @returns Recommender object with all details, or null if failed\n     */\n\n    async getOrCreateRecommenderWithDiscordId(\n        discordId: string\n    ): Promise<Recommender | null> {\n        try {\n            // Begin a transaction\n            const transaction = this.db.transaction(() => {\n                // Attempt to retrieve the recommender\n                const existingRecommender = this.getRecommender(discordId);\n                if (existingRecommender) {\n                    // Recommender exists, ensure metrics are initialized\n                    this.initializeRecommenderMetrics(existingRecommender.id!);\n                    return existingRecommender;\n                }\n\n                // Recommender does not exist, create a new one\n                const newRecommender = {\n                    id: uuidv4(),\n                    address: discordId,\n                    discordId: discordId,\n                };\n                const newRecommenderId = this.addRecommender(newRecommender);\n                if (!newRecommenderId) {\n                    throw new Error(\"Failed to add new recommender.\");\n                }\n\n                // Initialize metrics for the new recommender\n                const metricsInitialized =\n                    this.initializeRecommenderMetrics(newRecommenderId);\n                if (!metricsInitialized) {\n                    throw new Error(\n                        \"Failed to initialize recommender metrics.\"\n                    );\n                }\n\n                // Retrieve and return the newly created recommender\n                const recommender = this.getRecommender(newRecommenderId);\n                if (!recommender) {\n                    throw new Error(\n                        \"Failed to retrieve the newly created recommender.\"\n                    );\n                }\n\n                return recommender;\n            });\n\n            // Execute the transaction and return the recommender\n            const recommenderResult = transaction();\n            return recommenderResult;\n        } catch (error) {\n            console.error(\n                \"Error in getOrCreateRecommenderWithDiscordId:\",\n                error\n            );\n            return null;\n        }\n    }\n\n    /**\n     * Retrieves an existing recommender or creates a new one if not found.\n     * Also initializes metrics for the recommender if they haven't been initialized yet.\n     * @param telegramId Telegram ID of the recommender\n     * @returns Recommender object with all details, or null if failed\n     */\n\n    async getOrCreateRecommenderWithTelegramId(\n        telegramId: string\n    ): Promise<Recommender | null> {\n        try {\n            // Begin a transaction\n            const transaction = this.db.transaction(() => {\n                // Attempt to retrieve the recommender\n                const existingRecommender = this.getRecommender(telegramId);\n                if (existingRecommender) {\n                    // Recommender exists, ensure metrics are initialized\n                    this.initializeRecommenderMetrics(existingRecommender.id!);\n                    return existingRecommender;\n                }\n\n                // Recommender does not exist, create a new one\n                const newRecommender = {\n                    id: uuidv4(),\n                    address: telegramId,\n                    telegramId: telegramId,\n                };\n                const newRecommenderId = this.addRecommender(newRecommender);\n                if (!newRecommenderId) {\n                    throw new Error(\"Failed to add new recommender.\");\n                }\n\n                // Initialize metrics for the new recommender\n                const metricsInitialized =\n                    this.initializeRecommenderMetrics(newRecommenderId);\n                if (!metricsInitialized) {\n                    throw new Error(\n                        \"Failed to initialize recommender metrics.\"\n                    );\n                }\n\n                // Retrieve and return the newly created recommender\n                const recommender = this.getRecommender(newRecommenderId);\n                if (!recommender) {\n                    throw new Error(\n                        \"Failed to retrieve the newly created recommender.\"\n                    );\n                }\n\n                return recommender;\n            });\n\n            // Execute the transaction and return the recommender\n            const recommenderResult = transaction();\n            return recommenderResult;\n        } catch (error) {\n            console.error(\n                \"Error in getOrCreateRecommenderWithTelegramId:\",\n                error\n            );\n            return null;\n        }\n    }\n\n    /**\n     * Initializes metrics for a recommender if not present.\n     * @param recommenderId Recommender's UUID\n     */\n    initializeRecommenderMetrics(recommenderId: string): boolean {\n        const sql = `\n            INSERT OR IGNORE INTO recommender_metrics (recommender_id)\n            VALUES (?);\n        `;\n        try {\n            const result = this.db.prepare(sql).run(recommenderId);\n            return result.changes > 0;\n        } catch (error) {\n            console.error(\"Error initializing recommender metrics:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Retrieves metrics for a recommender.\n     * @param recommenderId Recommender's UUID\n     * @returns RecommenderMetrics object or null\n     */\n    getRecommenderMetrics(recommenderId: string): RecommenderMetrics | null {\n        const sql = `SELECT * FROM recommender_metrics WHERE recommender_id = ?;`;\n        const row = this.db.prepare(sql).get(recommenderId) as\n            | RecommenderMetricsRow\n            | undefined;\n        if (!row) return null;\n\n        return {\n            recommenderId: row.recommender_id,\n            trustScore: row.trust_score,\n            totalRecommendations: row.total_recommendations,\n            successfulRecs: row.successful_recs,\n            avgTokenPerformance: row.avg_token_performance,\n            riskScore: row.risk_score,\n            consistencyScore: row.consistency_score,\n            virtualConfidence: row.virtual_confidence,\n            lastActiveDate: row.last_active_date,\n            trustDecay: row.trust_decay,\n            lastUpdated: new Date(row.last_updated),\n        };\n    }\n\n    /**\n     * Logs the current metrics of a recommender into the history table.\n     * @param recommenderId Recommender's UUID\n     */\n    logRecommenderMetricsHistory(recommenderId: string): void {\n        // Retrieve current metrics\n        const currentMetrics = this.getRecommenderMetrics(recommenderId);\n        if (!currentMetrics) {\n            console.warn(\n                `No metrics found for recommender ID: ${recommenderId}`\n            );\n            return;\n        }\n\n        // Create a history entry\n        const history: RecommenderMetricsHistory = {\n            historyId: uuidv4(),\n            recommenderId: currentMetrics.recommenderId,\n            trustScore: currentMetrics.trustScore,\n            totalRecommendations: currentMetrics.totalRecommendations,\n            successfulRecs: currentMetrics.successfulRecs,\n            avgTokenPerformance: currentMetrics.avgTokenPerformance,\n            riskScore: currentMetrics.riskScore,\n            consistencyScore: currentMetrics.consistencyScore,\n            virtualConfidence: currentMetrics.virtualConfidence,\n            trustDecay: currentMetrics.trustDecay,\n            recordedAt: new Date(), // Current timestamp\n        };\n\n        // Insert into recommender_metrics_history table\n        const sql = `\n            INSERT INTO recommender_metrics_history (\n                history_id,\n                recommender_id,\n                trust_score,\n                total_recommendations,\n                successful_recs,\n                avg_token_performance,\n                risk_score,\n                consistency_score,\n                recorded_at\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);\n        `;\n        try {\n            this.db\n                .prepare(sql)\n                .run(\n                    history.historyId,\n                    history.recommenderId,\n                    history.trustScore,\n                    history.totalRecommendations,\n                    history.successfulRecs,\n                    history.avgTokenPerformance,\n                    history.riskScore,\n                    history.consistencyScore,\n                    history.recordedAt.toISOString()\n                );\n            console.log(\n                `Logged metrics history for recommender ID: ${recommenderId}`\n            );\n        } catch (error) {\n            console.error(\"Error logging recommender metrics history:\", error);\n        }\n    }\n\n    /**\n     * Updates metrics for a recommender.\n     * @param metrics RecommenderMetrics object\n     */\n    updateRecommenderMetrics(metrics: RecommenderMetrics): void {\n        // Log current metrics before updating\n        this.logRecommenderMetricsHistory(metrics.recommenderId);\n\n        const sql = `\n            UPDATE recommender_metrics\n            SET trust_score = ?,\n                total_recommendations = ?,\n                successful_recs = ?,\n                avg_token_performance = ?,\n                risk_score = ?,\n                consistency_score = ?,\n                last_updated = CURRENT_TIMESTAMP\n            WHERE recommender_id = ?;\n        `;\n        try {\n            this.db\n                .prepare(sql)\n                .run(\n                    metrics.trustScore,\n                    metrics.totalRecommendations,\n                    metrics.successfulRecs,\n                    metrics.avgTokenPerformance,\n                    metrics.riskScore,\n                    metrics.consistencyScore,\n                    metrics.recommenderId\n                );\n            console.log(\n                `Updated metrics for recommender ID: ${metrics.recommenderId}`\n            );\n        } catch (error) {\n            console.error(\"Error updating recommender metrics:\", error);\n        }\n    }\n\n    // ----- TokenPerformance Methods -----\n\n    /**\n     * Adds or updates token performance metrics.\n     * @param performance TokenPerformance object\n     */\n    upsertTokenPerformance(performance: TokenPerformance): boolean {\n        const validationTrust = this.calculateValidationTrust(\n            performance.tokenAddress\n        );\n\n        const sql = `\n            INSERT INTO token_performance (\n                token_address,\n                price_change_24h,\n                volume_change_24h,\n                trade_24h_change,\n                liquidity,\n                liquidity_change_24h,\n                holder_change_24h,\n                rug_pull,\n                is_scam,\n                market_cap_change24h,\n                sustained_growth,\n                rapid_dump,\n                suspicious_volume,\n                validation_trust,\n                balance,\n                initial_market_cap,\n                last_updated\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n            ON CONFLICT(token_address) DO UPDATE SET\n                price_change_24h = excluded.price_change_24h,\n                volume_change_24h = excluded.volume_change_24h,\n                trade_24h_change = excluded.trade_24h_change,\n                liquidity = excluded.liquidity,\n                liquidity_change_24h = excluded.liquidity_change_24h,\n                holder_change_24h = excluded.holder_change_24h,\n                rug_pull = excluded.rug_pull,\n                is_scam = excluded.is_scam,\n                market_cap_change24h = excluded.market_cap_change24h,\n                sustained_growth = excluded.sustained_growth,\n                rapid_dump = excluded.rapid_dump,\n                suspicious_volume = excluded.suspicious_volume,\n                validation_trust = excluded.validation_trust,\n                balance = excluded.balance,\n                initial_market_cap = excluded.initial_market_cap,\n                last_updated = CURRENT_TIMESTAMP;\n        `;\n        try {\n            this.db.prepare(sql).run(\n                performance.tokenAddress,\n                performance.priceChange24h,\n                performance.volumeChange24h,\n                performance.trade_24h_change,\n                performance.liquidity,\n                performance.liquidityChange24h,\n                performance.holderChange24h, // Ensure column name matches schema\n                performance.rugPull ? 1 : 0,\n                performance.isScam ? 1 : 0,\n                performance.marketCapChange24h,\n                performance.sustainedGrowth ? 1 : 0,\n                performance.rapidDump ? 1 : 0,\n                performance.suspiciousVolume ? 1 : 0,\n                performance.balance,\n                performance.initialMarketCap,\n                validationTrust\n            );\n            console.log(\n                `Upserted token performance for ${performance.tokenAddress}`\n            );\n            return true;\n        } catch (error) {\n            console.error(\"Error upserting token performance:\", error);\n            return false;\n        }\n    }\n\n    // update token balance\n\n    updateTokenBalance(tokenAddress: string, balance: number): boolean {\n        const sql = `\n            UPDATE token_performance\n            SET balance = ?,\n                last_updated = CURRENT_TIMESTAMP\n            WHERE token_address = ?;\n        `;\n        try {\n            this.db.prepare(sql).run(balance, tokenAddress);\n            console.log(`Updated token balance for ${tokenAddress}`);\n            return true;\n        } catch (error) {\n            console.error(\"Error updating token balance:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Retrieves token performance metrics.\n     * @param tokenAddress Token's address\n     * @returns TokenPerformance object or null\n     */\n    getTokenPerformance(tokenAddress: string): TokenPerformance | null {\n        const sql = `SELECT * FROM token_performance WHERE token_address = ?;`;\n        const row = this.db.prepare(sql).get(tokenAddress) as\n            | TokenPerformanceRow\n            | undefined;\n        if (!row) return null;\n\n        return {\n            tokenAddress: row.token_address,\n            symbol: row.symbol,\n            priceChange24h: row.price_change_24h,\n            volumeChange24h: row.volume_change_24h,\n            trade_24h_change: row.trade_24h_change,\n            liquidity: row.liquidity,\n            liquidityChange24h: row.liquidity_change_24h,\n            holderChange24h: row.holder_change_24h,\n            rugPull: row.rug_pull === 1,\n            isScam: row.is_scam === 1,\n            marketCapChange24h: row.market_cap_change24h,\n            sustainedGrowth: row.sustained_growth === 1,\n            rapidDump: row.rapid_dump === 1,\n            suspiciousVolume: row.suspicious_volume === 1,\n            validationTrust: row.validation_trust,\n            balance: row.balance,\n            initialMarketCap: row.initial_market_cap,\n            lastUpdated: new Date(row.last_updated),\n        };\n    }\n\n    //getTokenBalance\n    getTokenBalance(tokenAddress: string): number {\n        const sql = `SELECT balance FROM token_performance WHERE token_address = ?;`;\n        const row = this.db.prepare(sql).get(tokenAddress) as {\n            balance: number;\n        };\n        return row.balance;\n    }\n\n    getAllTokenPerformancesWithBalance(): TokenPerformance[] {\n        const sql = `SELECT * FROM token_performance WHERE balance > 0;`;\n        const rows = this.db.prepare(sql).all() as TokenPerformanceRow[];\n\n        return rows.map((row) => ({\n            tokenAddress: row.token_address,\n            symbol: row.symbol,\n            priceChange24h: row.price_change_24h,\n            volumeChange24h: row.volume_change_24h,\n            trade_24h_change: row.trade_24h_change,\n            liquidity: row.liquidity,\n            liquidityChange24h: row.liquidity_change_24h,\n            holderChange24h: row.holder_change_24h,\n            rugPull: row.rug_pull === 1,\n            isScam: row.is_scam === 1,\n            marketCapChange24h: row.market_cap_change24h,\n            sustainedGrowth: row.sustained_growth === 1,\n            rapidDump: row.rapid_dump === 1,\n            suspiciousVolume: row.suspicious_volume === 1,\n            validationTrust: row.validation_trust,\n            balance: row.balance,\n            initialMarketCap: row.initial_market_cap,\n            lastUpdated: new Date(row.last_updated),\n        }));\n    }\n\n    // ----- TokenRecommendations Methods -----\n\n    /**\n     * Calculates the average trust score of all recommenders who have recommended a specific token.\n     * @param tokenAddress The address of the token.\n     * @returns The average trust score (validationTrust).\n     */\n    calculateValidationTrust(tokenAddress: string): number {\n        const sql = `\n        SELECT rm.trust_score\n        FROM token_recommendations tr\n        JOIN recommender_metrics rm ON tr.recommender_id = rm.recommender_id\n        WHERE tr.token_address = ?;\n    `;\n        const rows = this.db.prepare(sql).all(tokenAddress) as Array<{\n            trust_score: number;\n        }>;\n\n        if (rows.length === 0) return 0; // No recommendations found\n\n        const totalTrust = rows.reduce((acc, row) => acc + row.trust_score, 0);\n        const averageTrust = totalTrust / rows.length;\n        return averageTrust;\n    }\n\n    /**\n     * Adds a new token recommendation.\n     * @param recommendation TokenRecommendation object\n     * @returns boolean indicating success\n     */\n    addTokenRecommendation(recommendation: TokenRecommendation): boolean {\n        const sql = `\n            INSERT INTO token_recommendations (\n                id,\n                recommender_id,\n                token_address,\n                timestamp,\n                initial_market_cap,\n                initial_liquidity,\n                initial_price\n            ) VALUES (?, ?, ?, ?, ?, ?, ?);\n        `;\n        try {\n            this.db\n                .prepare(sql)\n                .run(\n                    recommendation.id || uuidv4(),\n                    recommendation.recommenderId,\n                    recommendation.tokenAddress,\n                    recommendation.timestamp || new Date(),\n                    recommendation.initialMarketCap || null,\n                    recommendation.initialLiquidity || null,\n                    recommendation.initialPrice || null\n                );\n            return true;\n        } catch (error) {\n            console.error(\"Error adding token recommendation:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Retrieves all recommendations made by a recommender.\n     * @param recommenderId Recommender's UUID\n     * @returns Array of TokenRecommendation objects\n     */\n    getRecommendationsByRecommender(\n        recommenderId: string\n    ): TokenRecommendation[] {\n        const sql = `SELECT * FROM token_recommendations WHERE recommender_id = ? ORDER BY timestamp DESC;`;\n        const rows = this.db.prepare(sql).all(recommenderId) as Array<{\n            id: string;\n            recommender_id: string;\n            token_address: string;\n            timestamp: string;\n            initial_market_cap: number | null;\n            initial_liquidity: number | null;\n            initial_price: number | null;\n        }>;\n\n        return rows.map((row) => ({\n            id: row.id,\n            recommenderId: row.recommender_id,\n            tokenAddress: row.token_address,\n            timestamp: new Date(row.timestamp),\n            initialMarketCap: row.initial_market_cap,\n            initialLiquidity: row.initial_liquidity,\n            initialPrice: row.initial_price,\n        }));\n    }\n\n    /**\n     * Retrieves all recommendations for a specific token.\n     * @param tokenAddress Token's address\n     * @returns Array of TokenRecommendation objects\n     */\n    getRecommendationsByToken(tokenAddress: string): TokenRecommendation[] {\n        const sql = `SELECT * FROM token_recommendations WHERE token_address = ? ORDER BY timestamp DESC;`;\n        const rows = this.db.prepare(sql).all(tokenAddress) as Array<{\n            id: string;\n            recommender_id: string;\n            token_address: string;\n            timestamp: string;\n            initial_market_cap: number | null;\n            initial_liquidity: number | null;\n            initial_price: number | null;\n        }>;\n\n        return rows.map((row) => ({\n            id: row.id,\n            recommenderId: row.recommender_id,\n            tokenAddress: row.token_address,\n            timestamp: new Date(row.timestamp),\n            initialMarketCap: row.initial_market_cap ?? undefined,\n            initialLiquidity: row.initial_liquidity ?? undefined,\n            initialPrice: row.initial_price ?? undefined,\n        }));\n    }\n\n    /**\n     * Retrieves all recommendations within a specific timeframe.\n     * @param startDate Start date\n     * @param endDate End date\n     * @returns Array of TokenRecommendation objects\n     */\n    getRecommendationsByDateRange(\n        startDate: Date,\n        endDate: Date\n    ): TokenRecommendation[] {\n        const sql = `\n            SELECT * FROM token_recommendations\n            WHERE timestamp BETWEEN ? AND ?\n            ORDER BY timestamp DESC;\n        `;\n        const rows = this.db\n            .prepare(sql)\n            .all(startDate.toISOString(), endDate.toISOString()) as Array<{\n            id: string;\n            recommender_id: string;\n            token_address: string;\n            timestamp: string;\n            initial_market_cap: number | null;\n            initial_liquidity: number | null;\n            initial_price: number | null;\n        }>;\n\n        return rows.map((row) => ({\n            id: row.id,\n            recommenderId: row.recommender_id,\n            tokenAddress: row.token_address,\n            timestamp: new Date(row.timestamp),\n            initialMarketCap: row.initial_market_cap ?? undefined,\n            initialLiquidity: row.initial_liquidity ?? undefined,\n            initialPrice: row.initial_price ?? undefined,\n        }));\n    }\n\n    /**\n     * Retrieves historical metrics for a recommender.\n     * @param recommenderId Recommender's UUID\n     * @returns Array of RecommenderMetricsHistory objects\n     */\n    getRecommenderMetricsHistory(\n        recommenderId: string\n    ): RecommenderMetricsHistory[] {\n        const sql = `\n          SELECT * FROM recommender_metrics_history\n          WHERE recommender_id = ?\n          ORDER BY recorded_at DESC;\n      `;\n        const rows = this.db.prepare(sql).all(recommenderId) as Array<{\n            history_id: string;\n            recommender_id: string;\n            trust_score: number;\n            total_recommendations: number;\n            successful_recs: number;\n            avg_token_performance: number;\n            risk_score: number;\n            consistency_score: number;\n            virtual_confidence: number;\n            trust_decay: number;\n            recorded_at: string;\n        }>;\n\n        return rows.map((row) => ({\n            historyId: row.history_id,\n            recommenderId: row.recommender_id,\n            trustScore: row.trust_score,\n            totalRecommendations: row.total_recommendations,\n            successfulRecs: row.successful_recs,\n            avgTokenPerformance: row.avg_token_performance,\n            riskScore: row.risk_score,\n            consistencyScore: row.consistency_score,\n            virtualConfidence: row.virtual_confidence,\n            trustDecay: row.trust_decay,\n            recordedAt: new Date(row.recorded_at),\n        }));\n    }\n\n    /**\n     * Inserts a new trade performance into the specified table.\n     * @param trade The TradePerformance object containing trade details.\n     * @param isSimulation Whether the trade is a simulation. If true, inserts into simulation_trade; otherwise, into trade.\n     * @returns boolean indicating success.\n     */\n    addTradePerformance(\n        trade: TradePerformance,\n        isSimulation: boolean\n    ): boolean {\n        const tableName = isSimulation ? \"simulation_trade\" : \"trade\";\n        const sql = `\n      INSERT INTO ${tableName} (\n          token_address,\n          recommender_id,\n          buy_price,\n          sell_price,\n          buy_timeStamp,\n          sell_timeStamp,\n          buy_amount,\n          sell_amount,\n          buy_sol,\n          received_sol,\n          buy_value_usd,\n          sell_value_usd,\n          profit_usd,\n          profit_percent,\n          buy_market_cap,\n          sell_market_cap,\n          market_cap_change,\n          buy_liquidity,\n          sell_liquidity,\n          liquidity_change,\n          last_updated,\n          rapidDump\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\n  `;\n        try {\n            this.db\n                .prepare(sql)\n                .run(\n                    trade.token_address,\n                    trade.recommender_id,\n                    trade.buy_price,\n                    trade.sell_price || null,\n                    trade.buy_timeStamp,\n                    trade.sell_timeStamp || null,\n                    trade.buy_amount,\n                    trade.sell_amount || null,\n                    trade.buy_sol,\n                    trade.received_sol || null,\n                    trade.buy_value_usd,\n                    trade.sell_value_usd || null,\n                    trade.profit_usd || null,\n                    trade.profit_percent || null,\n                    trade.buy_market_cap,\n                    trade.sell_market_cap || null,\n                    trade.market_cap_change || null,\n                    trade.buy_liquidity,\n                    trade.sell_liquidity || null,\n                    trade.liquidity_change || null,\n                    trade.last_updated || new Date().toISOString(),\n                    trade.rapidDump ? 1 : 0\n                );\n            console.log(`Inserted trade into ${tableName}:`, trade);\n            return true;\n        } catch (error) {\n            console.error(`Error inserting trade into ${tableName}:`, error);\n            return false;\n        }\n    }\n\n    /**\n     * Updates an existing trade with sell details.\n     * @param tokenAddress The address of the token.\n     * @param recommenderId The UUID of the recommender.\n     * @param buyTimeStamp The timestamp when the buy occurred.\n     * @param sellDetails An object containing sell-related details.\n     * @param isSimulation Whether the trade is a simulation. If true, updates in simulation_trade; otherwise, in trade.\n     * @returns boolean indicating success.\n     */\n\n    updateTradePerformanceOnSell(\n        tokenAddress: string,\n        recommenderId: string,\n        buyTimeStamp: string,\n        sellDetails: {\n            sell_price: number;\n            sell_timeStamp: string;\n            sell_amount: number;\n            received_sol: number;\n            sell_value_usd: number;\n            profit_usd: number;\n            profit_percent: number;\n            sell_market_cap: number;\n            market_cap_change: number;\n            sell_liquidity: number;\n            liquidity_change: number;\n            rapidDump: boolean;\n            sell_recommender_id: string | null;\n        },\n        isSimulation: boolean\n    ): boolean {\n        const tableName = isSimulation ? \"simulation_trade\" : \"trade\";\n        const sql = `\n        UPDATE ${tableName}\n        SET\n            sell_price = ?,\n            sell_timeStamp = ?,\n            sell_amount = ?,\n            received_sol = ?,\n            sell_value_usd = ?,\n            profit_usd = ?,\n            profit_percent = ?,\n            sell_market_cap = ?,\n            market_cap_change = ?,\n            sell_liquidity = ?,\n            liquidity_change = ?,\n            rapidDump = ?,\n            sell_recommender_id = ?\n        WHERE\n            token_address = ?\n            AND recommender_id = ?\n            AND buy_timeStamp = ?;\n    `;\n        try {\n            const result = this.db\n                .prepare(sql)\n                .run(\n                    sellDetails.sell_price,\n                    sellDetails.sell_timeStamp,\n                    sellDetails.sell_amount,\n                    sellDetails.received_sol,\n                    sellDetails.sell_value_usd,\n                    sellDetails.profit_usd,\n                    sellDetails.profit_percent,\n                    sellDetails.sell_market_cap,\n                    sellDetails.market_cap_change,\n                    sellDetails.sell_liquidity,\n                    sellDetails.liquidity_change,\n                    sellDetails.rapidDump ? 1 : 0,\n                    tokenAddress,\n                    recommenderId,\n                    buyTimeStamp\n                );\n\n            if (result.changes === 0) {\n                console.warn(\n                    `No trade found to update in ${tableName} for token: ${tokenAddress}, recommender: ${recommenderId}, buyTimeStamp: ${buyTimeStamp}`\n                );\n                return false;\n            }\n\n            console.log(`Updated trade in ${tableName}:`, {\n                token_address: tokenAddress,\n                recommender_id: recommenderId,\n                buy_timeStamp: buyTimeStamp,\n                ...sellDetails,\n            });\n            return true;\n        } catch (error) {\n            console.error(`Error updating trade in ${tableName}:`, error);\n            return false;\n        }\n    }\n\n    //getTradePerformance\n\n    /**\n     * Retrieves trade performance metrics.\n     * @param tokenAddress Token's address\n     * @param recommenderId Recommender's UUID\n     * @param buyTimeStamp Timestamp when the buy occurred\n     * @param isSimulation Whether the trade is a simulation. If true, retrieves from simulation_trade; otherwise, from trade.\n     * @returns TradePerformance object or null\n     */\n\n    getTradePerformance(\n        tokenAddress: string,\n        recommenderId: string,\n        buyTimeStamp: string,\n        isSimulation: boolean\n    ): TradePerformance | null {\n        const tableName = isSimulation ? \"simulation_trade\" : \"trade\";\n        const sql = `SELECT * FROM ${tableName} WHERE token_address = ? AND recommender_id = ? AND buy_timeStamp = ?;`;\n        const row = this.db\n            .prepare(sql)\n            .get(tokenAddress, recommenderId, buyTimeStamp) as\n            | TradePerformance\n            | undefined;\n        if (!row) return null;\n\n        return {\n            token_address: row.token_address,\n            recommender_id: row.recommender_id,\n            buy_price: row.buy_price,\n            sell_price: row.sell_price,\n            buy_timeStamp: row.buy_timeStamp,\n            sell_timeStamp: row.sell_timeStamp,\n            buy_amount: row.buy_amount,\n            sell_amount: row.sell_amount,\n            buy_sol: row.buy_sol,\n            received_sol: row.received_sol,\n            buy_value_usd: row.buy_value_usd,\n            sell_value_usd: row.sell_value_usd,\n            profit_usd: row.profit_usd,\n            profit_percent: row.profit_percent,\n            buy_market_cap: row.buy_market_cap,\n            sell_market_cap: row.sell_market_cap,\n            market_cap_change: row.market_cap_change,\n            buy_liquidity: row.buy_liquidity,\n            sell_liquidity: row.sell_liquidity,\n            liquidity_change: row.liquidity_change,\n            last_updated: row.last_updated,\n            rapidDump: row.rapidDump,\n        };\n    }\n\n    /**\n     * Retrieves the latest trade performance metrics without requiring buyTimeStamp.\n     * @param tokenAddress Token's address\n     * @param recommenderId Recommender's UUID\n     * @param isSimulation Whether the trade is a simulation. If true, retrieves from simulation_trade; otherwise, from trade.\n     * @returns TradePerformance object or null\n     */\n    getLatestTradePerformance(\n        tokenAddress: string,\n        recommenderId: string,\n        isSimulation: boolean\n    ): TradePerformance | null {\n        const tableName = isSimulation ? \"simulation_trade\" : \"trade\";\n        const sql = `\n        SELECT * FROM ${tableName}\n        WHERE token_address = ? AND recommender_id = ?\n        ORDER BY buy_timeStamp DESC\n        LIMIT 1;\n    `;\n        const row = this.db.prepare(sql).get(tokenAddress, recommenderId) as\n            | TradePerformance\n            | undefined;\n        if (!row) return null;\n\n        return {\n            token_address: row.token_address,\n            recommender_id: row.recommender_id,\n            buy_price: row.buy_price,\n            sell_price: row.sell_price,\n            buy_timeStamp: row.buy_timeStamp,\n            sell_timeStamp: row.sell_timeStamp,\n            buy_amount: row.buy_amount,\n            sell_amount: row.sell_amount,\n            buy_sol: row.buy_sol,\n            received_sol: row.received_sol,\n            buy_value_usd: row.buy_value_usd,\n            sell_value_usd: row.sell_value_usd,\n            profit_usd: row.profit_usd,\n            profit_percent: row.profit_percent,\n            buy_market_cap: row.buy_market_cap,\n            sell_market_cap: row.sell_market_cap,\n            market_cap_change: row.market_cap_change,\n            buy_liquidity: row.buy_liquidity,\n            sell_liquidity: row.sell_liquidity,\n            liquidity_change: row.liquidity_change,\n            last_updated: row.last_updated,\n            rapidDump: row.rapidDump,\n        };\n    }\n\n    // ----- Transactions Methods -----\n    /**\n     * Adds a new transaction to the database.\n     * @param transaction Transaction object\n     * @returns boolean indicating success\n     */\n\n    addTransaction(transaction: Transaction): boolean {\n        const sql = `\n        INSERT INTO transactions (\n            token_address,\n            transaction_hash,\n            type,\n            amount,\n            price,\n            is_simulation,\n            timestamp\n        ) VALUES (?, ?, ?, ?, ?, ?);\n    `;\n        try {\n            this.db\n                .prepare(sql)\n                .run(\n                    transaction.tokenAddress,\n                    transaction.transactionHash,\n                    transaction.type,\n                    transaction.amount,\n                    transaction.price,\n                    transaction.isSimulation,\n                    transaction.timestamp\n                );\n            return true;\n        } catch (error) {\n            console.error(\"Error adding transaction:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Retrieves all transactions for a specific token.\n     * @param tokenAddress Token's address\n     * @returns Array of Transaction objects\n     */\n    getTransactionsByToken(tokenAddress: string): Transaction[] {\n        const sql = `SELECT * FROM transactions WHERE token_address = ? ORDER BY timestamp DESC;`;\n        const rows = this.db.prepare(sql).all(tokenAddress) as Array<{\n            token_address: string;\n            transaction_hash: string;\n            type: string;\n            amount: number;\n            price: number;\n            is_simulation: boolean;\n            timestamp: string;\n        }>;\n\n        return rows.map((row) => {\n            // Validate and cast 'type' to ensure it matches the expected union type\n            if (row.type !== \"buy\" && row.type !== \"sell\") {\n                throw new Error(`Unexpected transaction type: ${row.type}`);\n            }\n\n            return {\n                tokenAddress: row.token_address,\n                transactionHash: row.transaction_hash,\n                type: row.type as \"buy\" | \"sell\",\n                amount: row.amount,\n                price: row.price,\n                isSimulation: row.is_simulation,\n                timestamp: new Date(row.timestamp).toISOString(),\n            };\n        });\n    }\n\n    /**\n     * Close the database connection gracefully.\n     */\n    closeConnection(): void {\n        this.db.close();\n    }\n}\n"],"mappings":"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","names":[]}