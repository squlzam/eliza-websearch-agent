{"version":3,"sources":["../src/index.ts","../src/handlers/createCollection.ts","../src/provider/wallet/walletSolana.ts","../src/handlers/createNFT.ts","../src/handlers/verifyNFT.ts","../src/api.ts"],"sourcesContent":["import {\n    Action,\n    elizaLogger,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    Plugin,\n    State,\n} from \"@elizaos/core\";\n\nimport { createCollection } from \"./handlers/createCollection.ts\";\nimport { createNFT } from \"./handlers/createNFT.ts\";\nimport { verifyNFT } from \"./handlers/verifyNFT.ts\";\n\nexport * from \"./provider/wallet/walletSolana.ts\";\nexport * from \"./api.ts\";\n\nexport async function sleep(ms: number = 3000) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\nconst nftCollectionGeneration: Action = {\n    name: \"GENERATE_COLLECTION\",\n    similes: [\n        \"COLLECTION_GENERATION\",\n        \"COLLECTION_GEN\",\n        \"CREATE_COLLECTION\",\n        \"MAKE_COLLECTION\",\n        \"GENERATE_COLLECTION\",\n    ],\n    description: \"Generate an NFT collection for the message\",\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        const AwsAccessKeyIdOk = !!runtime.getSetting(\"AWS_ACCESS_KEY_ID\");\n        const AwsSecretAccessKeyOk = !!runtime.getSetting(\n            \"AWS_SECRET_ACCESS_KEY\"\n        );\n        const AwsRegionOk = !!runtime.getSetting(\"AWS_REGION\");\n        const AwsS3BucketOk = !!runtime.getSetting(\"AWS_S3_BUCKET\");\n\n        return (\n            AwsAccessKeyIdOk ||\n            AwsSecretAccessKeyOk ||\n            AwsRegionOk ||\n            AwsS3BucketOk\n        );\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: { [key: string]: unknown },\n        callback: HandlerCallback\n    ) => {\n        try {\n            elizaLogger.log(\"Composing state for message:\", message);\n            const userId = runtime.agentId;\n            elizaLogger.log(\"User ID:\", userId);\n\n            const collectionAddressRes = await createCollection({\n                runtime,\n                collectionName: runtime.character.name,\n            });\n\n            const collectionInfo = collectionAddressRes.collectionInfo;\n\n            elizaLogger.log(\"Collection Address:\", collectionAddressRes);\n\n            const nftRes = await createNFT({\n                runtime,\n                collectionName: collectionInfo.name,\n                collectionAddress: collectionAddressRes.address,\n                collectionAdminPublicKey: collectionInfo.adminPublicKey,\n                collectionFee: collectionInfo.fee,\n                tokenId: 1,\n            });\n\n            elizaLogger.log(\"NFT Address:\", nftRes);\n\n            callback({\n                text: `Congratulations to you! ðŸŽ‰ðŸŽ‰ðŸŽ‰ \\nCollection : ${collectionAddressRes.link}\\n NFT: ${nftRes.link}`, //caption.description,\n                attachments: [],\n            });\n            await sleep(15000);\n            await verifyNFT({\n                runtime,\n                collectionAddress: collectionAddressRes.address,\n                NFTAddress: nftRes.address,\n            });\n            return [];\n        } catch (e: any) {\n            console.log(e);\n        }\n\n        // callback();\n    },\n    examples: [\n        // TODO: We want to generate images in more abstract ways, not just when asked to generate an image\n\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Generate a collection\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"Here's the collection you requested.\",\n                    action: \"GENERATE_COLLECTION\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Generate a collection using {{agentName}}\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"We've successfully created a collection.\",\n                    action: \"GENERATE_COLLECTION\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Create a collection using {{agentName}}\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"Here's the collection you requested.\",\n                    action: \"GENERATE_COLLECTION\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Build a Collection\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"The collection has been successfully built.\",\n                    action: \"GENERATE_COLLECTION\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Assemble a collection with {{agentName}}\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"The collection has been assembled\",\n                    action: \"GENERATE_COLLECTION\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Make a collection\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"The collection has been produced successfully.\",\n                    action: \"GENERATE_COLLECTION\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Compile a collection\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"The collection has been compiled.\",\n                    action: \"GENERATE_COLLECTION\",\n                },\n            },\n        ],\n    ],\n} as Action;\n\nexport const nftGenerationPlugin: Plugin = {\n    name: \"nftCollectionGeneration\",\n    description: \"Generate NFT Collections\",\n    actions: [nftCollectionGeneration],\n    evaluators: [],\n    providers: [],\n};\n","import { AwsS3Service } from \"@elizaos/plugin-node\";\nimport {\n    composeContext,\n    elizaLogger,\n    generateImage,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    Memory,\n    ServiceType,\n    stringToUuid,\n} from \"@elizaos/core\";\nimport {\n    saveBase64Image,\n    saveHeuristImage,\n} from \"@elizaos/plugin-image-generation\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport WalletSolana from \"../provider/wallet/walletSolana.ts\";\n\nconst collectionImageTemplate = `\nGenerate a logo with the text \"{{collectionName}}\", using orange as the main color, with a sci-fi and mysterious background theme\n`;\n\nexport async function createCollection({\n    runtime,\n    collectionName,\n    fee,\n}: {\n    runtime: IAgentRuntime;\n    collectionName: string;\n    fee?: number;\n}) {\n    const userId = runtime.agentId;\n    elizaLogger.log(\"User ID:\", userId);\n    const awsS3Service: AwsS3Service = runtime.getService(ServiceType.AWS_S3);\n    const agentName = runtime.character.name;\n    const roomId = stringToUuid(\"nft_generate_room-\" + agentName);\n    // Create memory for the message\n    const memory: Memory = {\n        agentId: userId,\n        userId,\n        roomId,\n        content: {\n            text: \"\",\n\n            source: \"nft-generator\",\n        },\n        createdAt: Date.now(),\n        embedding: getEmbeddingZeroVector(),\n    };\n    const state = await runtime.composeState(memory, {\n        collectionName,\n    });\n\n    const prompt = composeContext({\n        state,\n        template: collectionImageTemplate,\n    });\n    const images = await generateImage(\n        {\n            prompt,\n            width: 300,\n            height: 300,\n        },\n        runtime\n    );\n    if (images.success && images.data && images.data.length > 0) {\n        const image = images.data[0];\n        const filename = `collection-image`;\n        if (image.startsWith(\"http\")) {\n            elizaLogger.log(\"Generating image url:\", image);\n        }\n        // Choose save function based on image data format\n        const filepath = image.startsWith(\"http\")\n            ? await saveHeuristImage(image, filename)\n            : saveBase64Image(image, filename);\n\n        const logoPath = await awsS3Service.uploadFile(\n            filepath,\n            `/${collectionName}`,\n            false\n        );\n        const publicKey = runtime.getSetting(\"SOLANA_PUBLIC_KEY\");\n        const privateKey = runtime.getSetting(\"SOLANA_PRIVATE_KEY\");\n        const adminPublicKey = runtime.getSetting(\"SOLANA_ADMIN_PUBLIC_KEY\");\n        const collectionInfo = {\n            name: `${collectionName}`,\n            symbol: `${collectionName.toUpperCase()[0]}`,\n            adminPublicKey,\n            fee: fee || 0,\n            uri: \"\",\n        };\n        const jsonFilePath = await awsS3Service.uploadJson(\n            {\n                name: collectionInfo.name,\n                description: `${collectionInfo.name}`,\n                image: logoPath.url,\n            },\n            \"metadata.json\",\n            `${collectionName}`\n        );\n        collectionInfo.uri = jsonFilePath.url;\n\n        const wallet = new WalletSolana(new PublicKey(publicKey), privateKey);\n\n        const collectionAddressRes = await wallet.createCollection({\n            ...collectionInfo,\n        });\n\n        return {\n            network: \"solana\",\n            address: collectionAddressRes.address,\n            link: collectionAddressRes.link,\n            collectionInfo,\n        };\n    }\n\n    return;\n}\n","import NodeCache from \"node-cache\";\nimport {\n    Cluster,\n    clusterApiUrl,\n    Connection,\n    LAMPORTS_PER_SOL,\n    PublicKey,\n} from \"@solana/web3.js\";\nimport {\n    createNft,\n    findMetadataPda,\n    mplTokenMetadata,\n    updateV1,\n    verifyCollectionV1,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport {\n    generateSigner,\n    keypairIdentity,\n    percentAmount,\n    publicKey,\n    // sol,\n    TransactionBuilder,\n    Umi,\n} from \"@metaplex-foundation/umi\";\nimport { getExplorerLink } from \"@solana-developers/helpers\";\n// import { transferSol } from \"@metaplex-foundation/mpl-toolbox\";\nimport bs58 from \"bs58\";\nimport { elizaLogger } from \"@elizaos/core\";\n\nexport class WalletSolana {\n    private cache: NodeCache;\n    private umi: Umi;\n    private cluster: Cluster;\n\n    constructor(\n        private walletPublicKey: PublicKey,\n        private walletPrivateKeyKey: string,\n        private connection?: Connection\n    ) {\n        this.cache = new NodeCache({ stdTTL: 300 }); // Cache TTL set to 5 minutes\n\n        if (!connection) {\n            this.cluster = (process.env.SOLANA_CLUSTER as Cluster) || \"devnet\";\n            this.connection = new Connection(clusterApiUrl(this.cluster), {\n                commitment: \"finalized\",\n            });\n        }\n        const umi = createUmi(this.connection.rpcEndpoint);\n        umi.use(mplTokenMetadata());\n        const umiUser = umi.eddsa.createKeypairFromSecretKey(\n            this.privateKeyUint8Array\n        );\n        umi.use(keypairIdentity(umiUser));\n        this.umi = umi;\n    }\n\n    async getBalance() {\n        const balance = await this.connection.getBalance(this.walletPublicKey);\n        return {\n            value: balance,\n            formater: `${balance / LAMPORTS_PER_SOL} SOL`,\n        };\n    }\n\n    get privateKeyUint8Array() {\n        return bs58.decode(this.walletPrivateKeyKey);\n    }\n\n    async createCollection({\n        name,\n        symbol,\n        adminPublicKey,\n        uri,\n        fee,\n    }: {\n        name: string;\n        symbol: string;\n        adminPublicKey: string;\n        uri: string;\n        fee: number;\n    }): Promise<{\n        success: boolean;\n        link: string;\n        address: string;\n        error?: string | null;\n    }> {\n        try {\n            const collectionMint = generateSigner(this.umi);\n            let transaction = new TransactionBuilder();\n            const info = {\n                name,\n                symbol,\n                uri,\n            };\n            transaction = transaction.add(\n                createNft(this.umi, {\n                    ...info,\n                    mint: collectionMint,\n                    sellerFeeBasisPoints: percentAmount(fee),\n                    isCollection: true,\n                })\n            );\n\n            transaction = transaction.add(\n                updateV1(this.umi, {\n                    mint: collectionMint.publicKey,\n                    newUpdateAuthority: publicKey(adminPublicKey), // updateAuthority's public key\n                })\n            );\n\n            await transaction.sendAndConfirm(this.umi, {\n                confirm: {},\n            });\n\n            const address = collectionMint.publicKey;\n            return {\n                success: true,\n                link: getExplorerLink(\"address\", address, this.cluster),\n                address,\n                error: null,\n            };\n        } catch (e) {\n            return {\n                success: false,\n                link: \"\",\n                address: \"\",\n                error: e.message,\n            };\n        }\n    }\n\n    async mintNFT({\n        collectionAddress,\n        adminPublicKey,\n        name,\n        symbol,\n        uri,\n        fee,\n    }: {\n        collectionAddress: string;\n        adminPublicKey: string;\n        name: string;\n        symbol: string;\n        uri: string;\n        fee: number;\n    }): Promise<{\n        success: boolean;\n        link: string;\n        address: string;\n        error?: string | null;\n    }> {\n        try {\n            const umi = this.umi;\n            const mint = generateSigner(umi);\n\n            let transaction = new TransactionBuilder();\n            elizaLogger.log(\"collection address\", collectionAddress);\n            const collectionAddressKey = publicKey(collectionAddress);\n\n            const info = {\n                name,\n                uri,\n                symbol,\n            };\n            transaction = transaction.add(\n                createNft(umi, {\n                    mint,\n                    ...info,\n                    sellerFeeBasisPoints: percentAmount(fee),\n                    collection: {\n                        key: collectionAddressKey,\n                        verified: false,\n                    },\n                })\n            );\n\n            transaction = transaction.add(\n                updateV1(umi, {\n                    mint: mint.publicKey,\n                    newUpdateAuthority: publicKey(adminPublicKey), // updateAuthority's public key\n                })\n            );\n\n            await transaction.sendAndConfirm(umi);\n\n            const address = mint.publicKey;\n            return {\n                success: true,\n                link: getExplorerLink(\"address\", address, this.cluster),\n                address,\n                error: null,\n            };\n        } catch (e) {\n            return {\n                success: false,\n                link: \"\",\n                address: \"\",\n                error: e.message,\n            };\n        }\n    }\n\n    async verifyNft({\n        collectionAddress,\n        nftAddress,\n    }: {\n        collectionAddress: string;\n        nftAddress: string;\n    }): Promise<{\n        isVerified: boolean;\n        error: string | null;\n    }> {\n        try {\n            const umi = this.umi;\n            const collectionAddressKey = publicKey(collectionAddress);\n            const nftAddressKey = publicKey(nftAddress);\n\n            let transaction = new TransactionBuilder();\n            transaction = transaction.add(\n                verifyCollectionV1(umi, {\n                    metadata: findMetadataPda(umi, { mint: nftAddressKey }),\n                    collectionMint: collectionAddressKey,\n                    authority: umi.identity,\n                })\n            );\n\n            await transaction.sendAndConfirm(umi);\n\n            elizaLogger.log(\n                `âœ… NFT ${nftAddress} verified as member of collection ${collectionAddress}! See Explorer at ${getExplorerLink(\n                    \"address\",\n                    nftAddress,\n                    this.cluster\n                )}`\n            );\n            return {\n                isVerified: true,\n                error: null,\n            };\n        } catch (e) {\n            return {\n                isVerified: false,\n                error: e.message,\n            };\n        }\n    }\n}\n\nexport default WalletSolana;\n","import { AwsS3Service } from \"@elizaos/plugin-node\";\nimport {\n    composeContext,\n    elizaLogger,\n    generateImage,\n    generateText,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    ServiceType,\n    stringToUuid,\n} from \"@elizaos/core\";\nimport {\n    saveBase64Image,\n    saveHeuristImage,\n} from \"@elizaos/plugin-image-generation\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport WalletSolana from \"../provider/wallet/walletSolana.ts\";\n\nconst nftTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n# Task: Generate an image to Prompt the  {{agentName}}'s appearance, with the total character count MUST be less than 280.\n`;\n\nexport async function createNFTMetadata({\n    runtime,\n    collectionName,\n    collectionAdminPublicKey,\n    collectionFee,\n    tokenId,\n}: {\n    runtime: IAgentRuntime;\n    collectionName: string;\n    collectionAdminPublicKey: string;\n    collectionFee: number;\n    tokenId: number;\n}) {\n    const userId = runtime.agentId;\n    elizaLogger.log(\"User ID:\", userId);\n    const awsS3Service: AwsS3Service = runtime.getService(ServiceType.AWS_S3);\n    const agentName = runtime.character.name;\n    const roomId = stringToUuid(\"nft_generate_room-\" + agentName);\n    // Create memory for the message\n    const memory: Memory = {\n        agentId: userId,\n        userId,\n        roomId,\n        content: {\n            text: \"\",\n            source: \"nft-generator\",\n        },\n        createdAt: Date.now(),\n        embedding: getEmbeddingZeroVector(),\n    };\n    const state = await runtime.composeState(memory, {\n        collectionName,\n    });\n\n    const context = composeContext({\n        state,\n        template: nftTemplate,\n    });\n\n    let nftPrompt = await generateText({\n        runtime,\n        context,\n        modelClass: ModelClass.MEDIUM,\n    });\n\n    nftPrompt += runtime.character?.nft?.prompt || \"\";\n    nftPrompt += \"The image should only feature one person.\";\n\n    const images = await generateImage(\n        {\n            prompt: nftPrompt,\n            width: 1024,\n            height: 1024,\n        },\n        runtime\n    );\n    elizaLogger.log(\"NFT Prompt:\", nftPrompt);\n    if (images.success && images.data && images.data.length > 0) {\n        const image = images.data[0];\n        const filename = `${tokenId}`;\n        if (image.startsWith(\"http\")) {\n            elizaLogger.log(\"Generating image url:\", image);\n        }\n        // Choose save function based on image data format\n        const filepath = image.startsWith(\"http\")\n            ? await saveHeuristImage(image, filename)\n            : saveBase64Image(image, filename);\n        const nftImage = await awsS3Service.uploadFile(\n            filepath,\n            `/${collectionName}/items/${tokenId}`,\n            false\n        );\n        const nftInfo = {\n            name: `${collectionName} #${tokenId}`,\n            description: `${collectionName} #${tokenId}`,\n            symbol: `#${tokenId}`,\n            adminPublicKey: collectionAdminPublicKey,\n            fee: collectionFee,\n            uri: \"\",\n        };\n        const jsonFilePath = await awsS3Service.uploadJson(\n            {\n                name: nftInfo.name,\n                description: nftInfo.description,\n                image: nftImage.url,\n            },\n            \"metadata.json\",\n            `/${collectionName}/items/${tokenId}`\n        );\n\n        nftInfo.uri = jsonFilePath.url;\n        return {\n            ...nftInfo,\n            imageUri: nftImage.url,\n        };\n    }\n    return null;\n}\n\nexport async function createNFT({\n    runtime,\n    collectionName,\n    collectionAddress,\n    collectionAdminPublicKey,\n    collectionFee,\n    tokenId,\n}: {\n    runtime: IAgentRuntime;\n    collectionName: string;\n    collectionAddress: string;\n    collectionAdminPublicKey: string;\n    collectionFee: number;\n    tokenId: number;\n}) {\n    const nftInfo = await createNFTMetadata({\n        runtime,\n        collectionName,\n        collectionAdminPublicKey,\n        collectionFee,\n        tokenId,\n    });\n    if (nftInfo) {\n        const publicKey = runtime.getSetting(\"SOLANA_PUBLIC_KEY\");\n        const privateKey = runtime.getSetting(\"SOLANA_PRIVATE_KEY\");\n\n        const wallet = new WalletSolana(new PublicKey(publicKey), privateKey);\n\n        const nftAddressRes = await wallet.mintNFT({\n            name: nftInfo.name,\n            uri: nftInfo.uri,\n            symbol: nftInfo.symbol,\n            collectionAddress,\n            adminPublicKey: collectionAdminPublicKey,\n            fee: collectionFee,\n        });\n        elizaLogger.log(\"NFT ID:\", nftAddressRes.address);\n        return {\n            network: \"solana\",\n            address: nftAddressRes.address,\n            link: nftAddressRes.link,\n            nftInfo,\n        };\n    }\n    return;\n}\n","import { IAgentRuntime } from \"@elizaos/core\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport WalletSolana from \"../provider/wallet/walletSolana.ts\";\n\nexport async function verifyNFT({\n    runtime,\n    collectionAddress,\n    NFTAddress,\n}: {\n    runtime: IAgentRuntime;\n    collectionAddress: string;\n    NFTAddress: string;\n}) {\n    const adminPublicKey = runtime.getSetting(\"SOLANA_ADMIN_PUBLIC_KEY\");\n    const adminPrivateKey = runtime.getSetting(\"SOLANA_ADMIN_PRIVATE_KEY\");\n    const adminWallet = new WalletSolana(\n        new PublicKey(adminPublicKey),\n        adminPrivateKey\n    );\n    await adminWallet.verifyNft({\n        collectionAddress,\n        nftAddress: NFTAddress,\n    });\n    return {\n        success: true,\n    };\n}\n","import express from \"express\";\n\nimport { AgentRuntime } from \"@elizaos/core\";\nimport { createCollection } from \"./handlers/createCollection.ts\";\nimport { createNFT, createNFTMetadata } from \"./handlers/createNFT.ts\";\nimport { verifyNFT } from \"./handlers/verifyNFT.ts\";\n\nexport function createNFTApiRouter(\n    agents: Map<string, AgentRuntime>\n): express.Router {\n    const router = express.Router();\n\n    router.post(\n        \"/api/nft-generation/create-collection\",\n        async (req: express.Request, res: express.Response) => {\n            const agentId = req.body.agentId;\n            const fee = req.body.fee || 0;\n            const runtime = agents.get(agentId);\n            if (!runtime) {\n                res.status(404).send(\"Agent not found\");\n                return;\n            }\n            try {\n                const collectionAddressRes = await createCollection({\n                    runtime,\n                    collectionName: runtime.character.name,\n                    fee,\n                });\n\n                res.json({\n                    success: true,\n                    data: collectionAddressRes,\n                });\n            } catch (e: any) {\n                console.log(e);\n                res.json({\n                    success: false,\n                    data: JSON.stringify(e),\n                });\n            }\n        }\n    );\n\n    router.post(\n        \"/api/nft-generation/create-nft-metadata\",\n        async (req: express.Request, res: express.Response) => {\n            const agentId = req.body.agentId;\n            const collectionName = req.body.collectionName;\n            const collectionAddress = req.body.collectionAddress;\n            const collectionAdminPublicKey = req.body.collectionAdminPublicKey;\n            const collectionFee = req.body.collectionFee;\n            const tokenId = req.body.tokenId;\n            const runtime = agents.get(agentId);\n            if (!runtime) {\n                res.status(404).send(\"Agent not found\");\n                return;\n            }\n\n            try {\n                const nftInfo = await createNFTMetadata({\n                    runtime,\n                    collectionName,\n                    collectionAdminPublicKey,\n                    collectionFee,\n                    tokenId,\n                });\n\n                res.json({\n                    success: true,\n                    data: {\n                        ...nftInfo,\n                        collectionAddress,\n                    },\n                });\n            } catch (e: any) {\n                console.log(e);\n                res.json({\n                    success: false,\n                    data: JSON.stringify(e),\n                });\n            }\n        }\n    );\n\n    router.post(\n        \"/api/nft-generation/create-nft\",\n        async (req: express.Request, res: express.Response) => {\n            const agentId = req.body.agentId;\n            const collectionName = req.body.collectionName;\n            const collectionAddress = req.body.collectionAddress;\n            const collectionAdminPublicKey = req.body.collectionAdminPublicKey;\n            const collectionFee = req.body.collectionFee;\n            const tokenId = req.body.tokenId;\n            const runtime = agents.get(agentId);\n            if (!runtime) {\n                res.status(404).send(\"Agent not found\");\n                return;\n            }\n\n            try {\n                const nftRes = await createNFT({\n                    runtime,\n                    collectionName,\n                    collectionAddress,\n                    collectionAdminPublicKey,\n                    collectionFee,\n                    tokenId,\n                });\n\n                res.json({\n                    success: true,\n                    data: nftRes,\n                });\n            } catch (e: any) {\n                console.log(e);\n                res.json({\n                    success: false,\n                    data: JSON.stringify(e),\n                });\n            }\n        }\n    );\n\n    router.post(\n        \"/api/nft-generation/verify-nft\",\n        async (req: express.Request, res: express.Response) => {\n            const agentId = req.body.agentId;\n            const collectionAddress = req.body.collectionAddress;\n            const NFTAddress = req.body.nftAddress;\n            const token = req.body.token;\n\n            const runtime = agents.get(agentId);\n            if (!runtime) {\n                res.status(404).send(\"Agent not found\");\n                return;\n            }\n            const verifyToken = runtime.getSetting(\"SOLANA_VERIFY_TOKEN\");\n            if (token !== verifyToken) {\n                res.status(401).send(\" Access denied for translation\");\n                return;\n            }\n            try {\n                const { success } = await verifyNFT({\n                    runtime,\n                    collectionAddress,\n                    NFTAddress,\n                });\n\n                res.json({\n                    success: true,\n                    data: success ? \"verified\" : \"unverified\",\n                });\n            } catch (e: any) {\n                console.log(e);\n                res.json({\n                    success: false,\n                    data: JSON.stringify(e),\n                });\n            }\n        }\n    );\n\n    return router;\n}\n"],"mappings":"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","names":["elizaLogger","elizaLogger","PublicKey","elizaLogger","publicKey","PublicKey","composeContext","elizaLogger","generateImage","getEmbeddingZeroVector","ServiceType","stringToUuid","saveBase64Image","saveHeuristImage","PublicKey","elizaLogger","ServiceType","stringToUuid","getEmbeddingZeroVector","composeContext","generateImage","saveHeuristImage","saveBase64Image","publicKey","PublicKey","PublicKey","PublicKey","elizaLogger"]}