{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { v4 } from \"uuid\";\n\n// Import the entire module as default\nimport pg from \"pg\";\ntype Pool = pg.Pool;\n\nimport {\n    QueryConfig,\n    QueryConfigValues,\n    QueryResult,\n    QueryResultRow,\n} from \"pg\";\nimport {\n    Account,\n    Actor,\n    GoalStatus,\n    type Goal,\n    type Memory,\n    type Relationship,\n    type UUID,\n    type IDatabaseCacheAdapter,\n    Participant,\n    elizaLogger,\n    getEmbeddingConfig,\n    DatabaseAdapter,\n    EmbeddingProvider,\n} from \"@elizaos/core\";\nimport fs from \"fs\";\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\n\nconst __filename = fileURLToPath(import.meta.url); // get the resolved path to the file\nconst __dirname = path.dirname(__filename); // get the name of the directory\n\nexport class PostgresDatabaseAdapter\n    extends DatabaseAdapter<Pool>\n    implements IDatabaseCacheAdapter\n{\n    private pool: Pool;\n    private readonly maxRetries: number = 3;\n    private readonly baseDelay: number = 1000; // 1 second\n    private readonly maxDelay: number = 10000; // 10 seconds\n    private readonly jitterMax: number = 1000; // 1 second\n    private readonly connectionTimeout: number = 5000; // 5 seconds\n\n    constructor(connectionConfig: any) {\n        super({\n            //circuitbreaker stuff\n            failureThreshold: 5,\n            resetTimeout: 60000,\n            halfOpenMaxAttempts: 3,\n        });\n\n        const defaultConfig = {\n            max: 20,\n            idleTimeoutMillis: 30000,\n            connectionTimeoutMillis: this.connectionTimeout,\n        };\n\n        this.pool = new pg.Pool({\n            ...defaultConfig,\n            ...connectionConfig, // Allow overriding defaults\n        });\n\n        this.pool.on(\"error\", (err) => {\n            elizaLogger.error(\"Unexpected pool error\", err);\n            this.handlePoolError(err);\n        });\n\n        this.setupPoolErrorHandling();\n        this.testConnection();\n    }\n\n    private setupPoolErrorHandling() {\n        process.on(\"SIGINT\", async () => {\n            await this.cleanup();\n            process.exit(0);\n        });\n\n        process.on(\"SIGTERM\", async () => {\n            await this.cleanup();\n            process.exit(0);\n        });\n\n        process.on(\"beforeExit\", async () => {\n            await this.cleanup();\n        });\n    }\n\n    private async withDatabase<T>(\n        operation: () => Promise<T>,\n        context: string\n    ): Promise<T> {\n        return this.withCircuitBreaker(async () => {\n            return this.withRetry(operation);\n        }, context);\n    }\n\n    private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n        let lastError: Error = new Error(\"Unknown error\"); // Initialize with default\n\n        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n            try {\n                return await operation();\n            } catch (error) {\n                lastError = error as Error;\n\n                if (attempt < this.maxRetries) {\n                    // Calculate delay with exponential backoff\n                    const backoffDelay = Math.min(\n                        this.baseDelay * Math.pow(2, attempt - 1),\n                        this.maxDelay\n                    );\n\n                    // Add jitter to prevent thundering herd\n                    const jitter = Math.random() * this.jitterMax;\n                    const delay = backoffDelay + jitter;\n\n                    elizaLogger.warn(\n                        `Database operation failed (attempt ${attempt}/${this.maxRetries}):`,\n                        {\n                            error:\n                                error instanceof Error\n                                    ? error.message\n                                    : String(error),\n                            nextRetryIn: `${(delay / 1000).toFixed(1)}s`,\n                        }\n                    );\n\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                } else {\n                    elizaLogger.error(\"Max retry attempts reached:\", {\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                        totalAttempts: attempt,\n                    });\n                    throw error instanceof Error\n                        ? error\n                        : new Error(String(error));\n                }\n            }\n        }\n\n        throw lastError;\n    }\n\n    private async handlePoolError(error: Error) {\n        elizaLogger.error(\"Pool error occurred, attempting to reconnect\", {\n            error: error.message,\n        });\n\n        try {\n            // Close existing pool\n            await this.pool.end();\n\n            // Create new pool\n            this.pool = new pg.Pool({\n                ...this.pool.options,\n                connectionTimeoutMillis: this.connectionTimeout,\n            });\n\n            await this.testConnection();\n            elizaLogger.success(\"Pool reconnection successful\");\n        } catch (reconnectError) {\n            elizaLogger.error(\"Failed to reconnect pool\", {\n                error:\n                    reconnectError instanceof Error\n                        ? reconnectError.message\n                        : String(reconnectError),\n            });\n            throw reconnectError;\n        }\n    }\n\n    async query<R extends QueryResultRow = any, I = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: QueryConfigValues<I>\n    ): Promise<QueryResult<R>> {\n        return this.withDatabase(async () => {\n            return await this.pool.query(queryTextOrConfig, values);\n        }, \"query\");\n    }\n\n    async init() {\n        await this.testConnection();\n\n        const client = await this.pool.connect();\n        try {\n            await client.query(\"BEGIN\");\n\n            // Set application settings for embedding dimension\n            const embeddingConfig = getEmbeddingConfig();\n            if (embeddingConfig.provider === EmbeddingProvider.OpenAI) {\n                await client.query(\"SET app.use_openai_embedding = 'true'\");\n                await client.query(\"SET app.use_ollama_embedding = 'false'\");\n                await client.query(\"SET app.use_gaianet_embedding = 'false'\");\n            } else if (embeddingConfig.provider === EmbeddingProvider.Ollama) {\n                await client.query(\"SET app.use_openai_embedding = 'false'\");\n                await client.query(\"SET app.use_ollama_embedding = 'true'\");\n                await client.query(\"SET app.use_gaianet_embedding = 'false'\");\n            } else if (embeddingConfig.provider === EmbeddingProvider.GaiaNet){\n                await client.query(\"SET app.use_openai_embedding = 'false'\");\n                await client.query(\"SET app.use_ollama_embedding = 'false'\");\n                await client.query(\"SET app.use_gaianet_embedding = 'true'\");\n            } else {\n                await client.query(\"SET app.use_openai_embedding = 'false'\");\n                await client.query(\"SET app.use_ollama_embedding = 'false'\");\n                await client.query(\"SET app.use_gaianet_embedding = 'false'\");\n            }\n\n            const schema = fs.readFileSync(\n                path.resolve(__dirname, \"../schema.sql\"),\n                \"utf8\"\n            );\n            await client.query(schema);\n\n            await client.query(\"COMMIT\");\n        } catch (error) {\n            await client.query(\"ROLLBACK\");\n            throw error;\n        } finally {\n            client.release();\n        }\n    }\n\n    async close() {\n        await this.pool.end();\n    }\n\n    async testConnection(): Promise<boolean> {\n        let client;\n        try {\n            client = await this.pool.connect();\n            const result = await client.query(\"SELECT NOW()\");\n            elizaLogger.success(\n                \"Database connection test successful:\",\n                result.rows[0]\n            );\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Database connection test failed:\", error);\n            throw new Error(\n                `Failed to connect to database: ${(error as Error).message}`\n            );\n        } finally {\n            if (client) client.release();\n        }\n    }\n\n    async cleanup(): Promise<void> {\n        try {\n            await this.pool.end();\n            elizaLogger.info(\"Database pool closed\");\n        } catch (error) {\n            elizaLogger.error(\"Error closing database pool:\", error);\n        }\n    }\n\n    async getRoom(roomId: UUID): Promise<UUID | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                \"SELECT id FROM rooms WHERE id = $1\",\n                [roomId]\n            );\n            return rows.length > 0 ? (rows[0].id as UUID) : null;\n        }, \"getRoom\");\n    }\n\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                `SELECT id, \"userId\", \"roomId\", \"last_message_read\"\n                FROM participants\n                WHERE \"userId\" = $1`,\n                [userId]\n            );\n            return rows as Participant[];\n        }, \"getParticipantsForAccount\");\n    }\n\n    async getParticipantUserState(\n        roomId: UUID,\n        userId: UUID\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                `SELECT \"userState\" FROM participants WHERE \"roomId\" = $1 AND \"userId\" = $2`,\n                [roomId, userId]\n            );\n            return rows.length > 0 ? rows[0].userState : null;\n        }, \"getParticipantUserState\");\n    }\n\n    async getMemoriesByRoomIds(params: {\n        roomIds: UUID[];\n        agentId?: UUID;\n        tableName: string;\n    }): Promise<Memory[]> {\n        return this.withDatabase(async () => {\n            if (params.roomIds.length === 0) return [];\n            const placeholders = params.roomIds\n                .map((_, i) => `$${i + 2}`)\n                .join(\", \");\n\n            let query = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" IN (${placeholders})`;\n            let queryParams = [params.tableName, ...params.roomIds];\n\n            if (params.agentId) {\n                query += ` AND \"agentId\" = $${params.roomIds.length + 2}`;\n                queryParams = [...queryParams, params.agentId];\n            }\n\n            const { rows } = await this.pool.query(query, queryParams);\n            return rows.map((row) => ({\n                ...row,\n                content:\n                    typeof row.content === \"string\"\n                        ? JSON.parse(row.content)\n                        : row.content,\n            }));\n        }, \"getMemoriesByRoomIds\");\n    }\n\n    async setParticipantUserState(\n        roomId: UUID,\n        userId: UUID,\n        state: \"FOLLOWED\" | \"MUTED\" | null\n    ): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.pool.query(\n                `UPDATE participants SET \"userState\" = $1 WHERE \"roomId\" = $2 AND \"userId\" = $3`,\n                [state, roomId, userId]\n            );\n        }, \"setParticipantUserState\");\n    }\n\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                'SELECT \"userId\" FROM participants WHERE \"roomId\" = $1',\n                [roomId]\n            );\n            return rows.map((row) => row.userId);\n        }, \"getParticipantsForRoom\");\n    }\n\n    async getAccountById(userId: UUID): Promise<Account | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                \"SELECT * FROM accounts WHERE id = $1\",\n                [userId]\n            );\n            if (rows.length === 0) {\n                elizaLogger.debug(\"Account not found:\", { userId });\n                return null;\n            }\n\n            const account = rows[0];\n            // elizaLogger.debug(\"Account retrieved:\", {\n            //     userId,\n            //     hasDetails: !!account.details,\n            // });\n\n            return {\n                ...account,\n                details:\n                    typeof account.details === \"string\"\n                        ? JSON.parse(account.details)\n                        : account.details,\n            };\n        }, \"getAccountById\");\n    }\n\n    async createAccount(account: Account): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                const accountId = account.id ?? v4();\n                await this.pool.query(\n                    `INSERT INTO accounts (id, name, username, email, \"avatarUrl\", details)\n                    VALUES ($1, $2, $3, $4, $5, $6)`,\n                    [\n                        accountId,\n                        account.name,\n                        account.username || \"\",\n                        account.email || \"\",\n                        account.avatarUrl || \"\",\n                        JSON.stringify(account.details),\n                    ]\n                );\n                elizaLogger.debug(\"Account created successfully:\", {\n                    accountId,\n                });\n                return true;\n            } catch (error) {\n                elizaLogger.error(\"Error creating account:\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    accountId: account.id,\n                    name: account.name, // Only log non-sensitive fields\n                });\n                return false; // Return false instead of throwing to maintain existing behavior\n            }\n        }, \"createAccount\");\n    }\n\n    async getActorById(params: { roomId: UUID }): Promise<Actor[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                `SELECT a.id, a.name, a.username, a.details\n                FROM participants p\n                LEFT JOIN accounts a ON p.\"userId\" = a.id\n                WHERE p.\"roomId\" = $1`,\n                [params.roomId]\n            );\n\n            elizaLogger.debug(\"Retrieved actors:\", {\n                roomId: params.roomId,\n                actorCount: rows.length,\n            });\n\n            return rows.map((row) => {\n                try {\n                    return {\n                        ...row,\n                        details:\n                            typeof row.details === \"string\"\n                                ? JSON.parse(row.details)\n                                : row.details,\n                    };\n                } catch (error) {\n                    elizaLogger.warn(\"Failed to parse actor details:\", {\n                        actorId: row.id,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                    });\n                    return {\n                        ...row,\n                        details: {}, // Provide default empty details on parse error\n                    };\n                }\n            });\n        }, \"getActorById\").catch((error) => {\n            elizaLogger.error(\"Failed to get actors:\", {\n                roomId: params.roomId,\n                error: error.message,\n            });\n            throw error; // Re-throw to let caller handle database errors\n        });\n    }\n\n    async getMemoryById(id: UUID): Promise<Memory | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                \"SELECT * FROM memories WHERE id = $1\",\n                [id]\n            );\n            if (rows.length === 0) return null;\n\n            return {\n                ...rows[0],\n                content:\n                    typeof rows[0].content === \"string\"\n                        ? JSON.parse(rows[0].content)\n                        : rows[0].content,\n            };\n        }, \"getMemoryById\");\n    }\n\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\n        return this.withDatabase(async () => {\n            elizaLogger.debug(\"PostgresAdapter createMemory:\", {\n                memoryId: memory.id,\n                embeddingLength: memory.embedding?.length,\n                contentLength: memory.content?.text?.length,\n            });\n\n            let isUnique = true;\n            if (memory.embedding) {\n                const similarMemories = await this.searchMemoriesByEmbedding(\n                    memory.embedding,\n                    {\n                        tableName,\n                        roomId: memory.roomId,\n                        match_threshold: 0.95,\n                        count: 1,\n                    }\n                );\n                isUnique = similarMemories.length === 0;\n            }\n\n            await this.pool.query(\n                `INSERT INTO memories (\n                    id, type, content, embedding, \"userId\", \"roomId\", \"agentId\", \"unique\", \"createdAt\"\n                ) VALUES ($1, $2, $3, $4, $5::uuid, $6::uuid, $7::uuid, $8, to_timestamp($9/1000.0))`,\n                [\n                    memory.id ?? v4(),\n                    tableName,\n                    JSON.stringify(memory.content),\n                    memory.embedding ? `[${memory.embedding.join(\",\")}]` : null,\n                    memory.userId,\n                    memory.roomId,\n                    memory.agentId,\n                    memory.unique ?? isUnique,\n                    Date.now(),\n                ]\n            );\n        }, \"createMemory\");\n    }\n\n    async searchMemories(params: {\n        tableName: string;\n        agentId: UUID;\n        roomId: UUID;\n        embedding: number[];\n        match_threshold: number;\n        match_count: number;\n        unique: boolean;\n    }): Promise<Memory[]> {\n        return await this.searchMemoriesByEmbedding(params.embedding, {\n            match_threshold: params.match_threshold,\n            count: params.match_count,\n            agentId: params.agentId,\n            roomId: params.roomId,\n            unique: params.unique,\n            tableName: params.tableName,\n        });\n    }\n\n    async getMemories(params: {\n        roomId: UUID;\n        count?: number;\n        unique?: boolean;\n        tableName: string;\n        agentId?: UUID;\n        start?: number;\n        end?: number;\n    }): Promise<Memory[]> {\n        // Parameter validation\n        if (!params.tableName) throw new Error(\"tableName is required\");\n        if (!params.roomId) throw new Error(\"roomId is required\");\n\n        return this.withDatabase(async () => {\n            // Build query\n            let sql = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" = $2`;\n            const values: any[] = [params.tableName, params.roomId];\n            let paramCount = 2;\n\n            // Add time range filters\n            if (params.start) {\n                paramCount++;\n                sql += ` AND \"createdAt\" >= to_timestamp($${paramCount})`;\n                values.push(params.start / 1000);\n            }\n\n            if (params.end) {\n                paramCount++;\n                sql += ` AND \"createdAt\" <= to_timestamp($${paramCount})`;\n                values.push(params.end / 1000);\n            }\n\n            // Add other filters\n            if (params.unique) {\n                sql += ` AND \"unique\" = true`;\n            }\n\n            if (params.agentId) {\n                paramCount++;\n                sql += ` AND \"agentId\" = $${paramCount}`;\n                values.push(params.agentId);\n            }\n\n            // Add ordering and limit\n            sql += ' ORDER BY \"createdAt\" DESC';\n\n            if (params.count) {\n                paramCount++;\n                sql += ` LIMIT $${paramCount}`;\n                values.push(params.count);\n            }\n\n            elizaLogger.debug(\"Fetching memories:\", {\n                roomId: params.roomId,\n                tableName: params.tableName,\n                unique: params.unique,\n                agentId: params.agentId,\n                timeRange:\n                    params.start || params.end\n                        ? {\n                              start: params.start\n                                  ? new Date(params.start).toISOString()\n                                  : undefined,\n                              end: params.end\n                                  ? new Date(params.end).toISOString()\n                                  : undefined,\n                          }\n                        : undefined,\n                limit: params.count,\n            });\n\n            const { rows } = await this.pool.query(sql, values);\n            return rows.map((row) => ({\n                ...row,\n                content:\n                    typeof row.content === \"string\"\n                        ? JSON.parse(row.content)\n                        : row.content,\n            }));\n        }, \"getMemories\");\n    }\n\n    async getGoals(params: {\n        roomId: UUID;\n        userId?: UUID | null;\n        onlyInProgress?: boolean;\n        count?: number;\n    }): Promise<Goal[]> {\n        return this.withDatabase(async () => {\n            let sql = `SELECT * FROM goals WHERE \"roomId\" = $1`;\n            const values: any[] = [params.roomId];\n            let paramCount = 1;\n\n            if (params.userId) {\n                paramCount++;\n                sql += ` AND \"userId\" = $${paramCount}`;\n                values.push(params.userId);\n            }\n\n            if (params.onlyInProgress) {\n                sql += \" AND status = 'IN_PROGRESS'\";\n            }\n\n            if (params.count) {\n                paramCount++;\n                sql += ` LIMIT $${paramCount}`;\n                values.push(params.count);\n            }\n\n            const { rows } = await this.pool.query(sql, values);\n            return rows.map((row) => ({\n                ...row,\n                objectives:\n                    typeof row.objectives === \"string\"\n                        ? JSON.parse(row.objectives)\n                        : row.objectives,\n            }));\n        }, \"getGoals\");\n    }\n\n    async updateGoal(goal: Goal): Promise<void> {\n        return this.withDatabase(async () => {\n            try {\n                await this.pool.query(\n                    `UPDATE goals SET name = $1, status = $2, objectives = $3 WHERE id = $4`,\n                    [\n                        goal.name,\n                        goal.status,\n                        JSON.stringify(goal.objectives),\n                        goal.id,\n                    ]\n                );\n            } catch (error) {\n                elizaLogger.error(\"Failed to update goal:\", {\n                    goalId: goal.id,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    status: goal.status,\n                });\n                throw error;\n            }\n        }, \"updateGoal\");\n    }\n\n    async createGoal(goal: Goal): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.pool.query(\n                `INSERT INTO goals (id, \"roomId\", \"userId\", name, status, objectives)\n                VALUES ($1, $2, $3, $4, $5, $6)`,\n                [\n                    goal.id ?? v4(),\n                    goal.roomId,\n                    goal.userId,\n                    goal.name,\n                    goal.status,\n                    JSON.stringify(goal.objectives),\n                ]\n            );\n        }, \"createGoal\");\n    }\n\n    async removeGoal(goalId: UUID): Promise<void> {\n        if (!goalId) throw new Error(\"Goal ID is required\");\n\n        return this.withDatabase(async () => {\n            try {\n                const result = await this.pool.query(\n                    \"DELETE FROM goals WHERE id = $1 RETURNING id\",\n                    [goalId]\n                );\n\n                elizaLogger.debug(\"Goal removal attempt:\", {\n                    goalId,\n                    removed: result?.rowCount ?? 0 > 0,\n                });\n            } catch (error) {\n                elizaLogger.error(\"Failed to remove goal:\", {\n                    goalId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"removeGoal\");\n    }\n\n    async createRoom(roomId?: UUID): Promise<UUID> {\n        return this.withDatabase(async () => {\n            const newRoomId = roomId || v4();\n            await this.pool.query(\"INSERT INTO rooms (id) VALUES ($1)\", [\n                newRoomId,\n            ]);\n            return newRoomId as UUID;\n        }, \"createRoom\");\n    }\n\n    async removeRoom(roomId: UUID): Promise<void> {\n        if (!roomId) throw new Error(\"Room ID is required\");\n\n        return this.withDatabase(async () => {\n            const client = await this.pool.connect();\n            try {\n                await client.query(\"BEGIN\");\n\n                // First check if room exists\n                const checkResult = await client.query(\n                    \"SELECT id FROM rooms WHERE id = $1\",\n                    [roomId]\n                );\n\n                if (checkResult.rowCount === 0) {\n                    elizaLogger.warn(\"No room found to remove:\", { roomId });\n                    throw new Error(`Room not found: ${roomId}`);\n                }\n\n                // Remove related data first (if not using CASCADE)\n                await client.query('DELETE FROM memories WHERE \"roomId\" = $1', [\n                    roomId,\n                ]);\n                await client.query(\n                    'DELETE FROM participants WHERE \"roomId\" = $1',\n                    [roomId]\n                );\n                await client.query('DELETE FROM goals WHERE \"roomId\" = $1', [\n                    roomId,\n                ]);\n\n                // Finally remove the room\n                const result = await client.query(\n                    \"DELETE FROM rooms WHERE id = $1 RETURNING id\",\n                    [roomId]\n                );\n\n                await client.query(\"COMMIT\");\n\n                elizaLogger.debug(\n                    \"Room and related data removed successfully:\",\n                    {\n                        roomId,\n                        removed: result?.rowCount ?? 0 > 0,\n                    }\n                );\n            } catch (error) {\n                await client.query(\"ROLLBACK\");\n                elizaLogger.error(\"Failed to remove room:\", {\n                    roomId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            } finally {\n                if (client) client.release();\n            }\n        }, \"removeRoom\");\n    }\n\n    async createRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<boolean> {\n        // Input validation\n        if (!params.userA || !params.userB) {\n            throw new Error(\"userA and userB are required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const relationshipId = v4();\n                await this.pool.query(\n                    `INSERT INTO relationships (id, \"userA\", \"userB\", \"userId\")\n                    VALUES ($1, $2, $3, $4)\n                    RETURNING id`,\n                    [relationshipId, params.userA, params.userB, params.userA]\n                );\n\n                elizaLogger.debug(\"Relationship created successfully:\", {\n                    relationshipId,\n                    userA: params.userA,\n                    userB: params.userB,\n                });\n\n                return true;\n            } catch (error) {\n                // Check for unique constraint violation or other specific errors\n                if ((error as { code?: string }).code === \"23505\") {\n                    // Unique violation\n                    elizaLogger.warn(\"Relationship already exists:\", {\n                        userA: params.userA,\n                        userB: params.userB,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                    });\n                } else {\n                    elizaLogger.error(\"Failed to create relationship:\", {\n                        userA: params.userA,\n                        userB: params.userB,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                    });\n                }\n                return false;\n            }\n        }, \"createRelationship\");\n    }\n\n    async getRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<Relationship | null> {\n        if (!params.userA || !params.userB) {\n            throw new Error(\"userA and userB are required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const { rows } = await this.pool.query(\n                    `SELECT * FROM relationships\n                    WHERE (\"userA\" = $1 AND \"userB\" = $2)\n                    OR (\"userA\" = $2 AND \"userB\" = $1)`,\n                    [params.userA, params.userB]\n                );\n\n                if (rows.length > 0) {\n                    elizaLogger.debug(\"Relationship found:\", {\n                        relationshipId: rows[0].id,\n                        userA: params.userA,\n                        userB: params.userB,\n                    });\n                    return rows[0];\n                }\n\n                elizaLogger.debug(\"No relationship found between users:\", {\n                    userA: params.userA,\n                    userB: params.userB,\n                });\n                return null;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching relationship:\", {\n                    userA: params.userA,\n                    userB: params.userB,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"getRelationship\");\n    }\n\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\n        if (!params.userId) {\n            throw new Error(\"userId is required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const { rows } = await this.pool.query(\n                    `SELECT * FROM relationships\n                    WHERE \"userA\" = $1 OR \"userB\" = $1\n                    ORDER BY \"createdAt\" DESC`, // Add ordering if you have this field\n                    [params.userId]\n                );\n\n                elizaLogger.debug(\"Retrieved relationships:\", {\n                    userId: params.userId,\n                    count: rows.length,\n                });\n\n                return rows;\n            } catch (error) {\n                elizaLogger.error(\"Failed to fetch relationships:\", {\n                    userId: params.userId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"getRelationships\");\n    }\n\n    async getCachedEmbeddings(opts: {\n        query_table_name: string;\n        query_threshold: number;\n        query_input: string;\n        query_field_name: string;\n        query_field_sub_name: string;\n        query_match_count: number;\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\n        // Input validation\n        if (!opts.query_table_name)\n            throw new Error(\"query_table_name is required\");\n        if (!opts.query_input) throw new Error(\"query_input is required\");\n        if (!opts.query_field_name)\n            throw new Error(\"query_field_name is required\");\n        if (!opts.query_field_sub_name)\n            throw new Error(\"query_field_sub_name is required\");\n        if (opts.query_match_count <= 0)\n            throw new Error(\"query_match_count must be positive\");\n\n        return this.withDatabase(async () => {\n            try {\n                elizaLogger.debug(\"Fetching cached embeddings:\", {\n                    tableName: opts.query_table_name,\n                    fieldName: opts.query_field_name,\n                    subFieldName: opts.query_field_sub_name,\n                    matchCount: opts.query_match_count,\n                    inputLength: opts.query_input.length,\n                });\n\n                const sql = `\n                    WITH content_text AS (\n                        SELECT\n                            embedding,\n                            COALESCE(\n                                content->$2->>$3,\n                                ''\n                            ) as content_text\n                        FROM memories\n                        WHERE type = $4\n                        AND content->$2->>$3 IS NOT NULL\n                    )\n                    SELECT\n                        embedding,\n                        levenshtein(\n                            $1,\n                            content_text\n                        ) as levenshtein_score\n                    FROM content_text\n                    WHERE levenshtein(\n                        $1,\n                        content_text\n                    ) <= $6  -- Add threshold check\n                    ORDER BY levenshtein_score\n                    LIMIT $5\n                `;\n\n                const { rows } = await this.pool.query(sql, [\n                    opts.query_input,\n                    opts.query_field_name,\n                    opts.query_field_sub_name,\n                    opts.query_table_name,\n                    opts.query_match_count,\n                    opts.query_threshold,\n                ]);\n\n                elizaLogger.debug(\"Retrieved cached embeddings:\", {\n                    count: rows.length,\n                    tableName: opts.query_table_name,\n                    matchCount: opts.query_match_count,\n                });\n\n                return rows\n                    .map(\n                        (\n                            row\n                        ): {\n                            embedding: number[];\n                            levenshtein_score: number;\n                        } | null => {\n                            if (!Array.isArray(row.embedding)) return null;\n                            return {\n                                embedding: row.embedding,\n                                levenshtein_score: Number(\n                                    row.levenshtein_score\n                                ),\n                            };\n                        }\n                    )\n                    .filter(\n                        (\n                            row\n                        ): row is {\n                            embedding: number[];\n                            levenshtein_score: number;\n                        } => row !== null\n                    );\n            } catch (error) {\n                elizaLogger.error(\"Error in getCachedEmbeddings:\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    tableName: opts.query_table_name,\n                    fieldName: opts.query_field_name,\n                });\n                throw error;\n            }\n        }, \"getCachedEmbeddings\");\n    }\n\n    async log(params: {\n        body: { [key: string]: unknown };\n        userId: UUID;\n        roomId: UUID;\n        type: string;\n    }): Promise<void> {\n        // Input validation\n        if (!params.userId) throw new Error(\"userId is required\");\n        if (!params.roomId) throw new Error(\"roomId is required\");\n        if (!params.type) throw new Error(\"type is required\");\n        if (!params.body || typeof params.body !== \"object\") {\n            throw new Error(\"body must be a valid object\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const logId = v4(); // Generate ID for tracking\n                await this.pool.query(\n                    `INSERT INTO logs (\n                        id,\n                        body,\n                        \"userId\",\n                        \"roomId\",\n                        type,\n                        \"createdAt\"\n                    ) VALUES ($1, $2, $3, $4, $5, NOW())\n                    RETURNING id`,\n                    [\n                        logId,\n                        JSON.stringify(params.body), // Ensure body is stringified\n                        params.userId,\n                        params.roomId,\n                        params.type,\n                    ]\n                );\n\n                elizaLogger.debug(\"Log entry created:\", {\n                    logId,\n                    type: params.type,\n                    roomId: params.roomId,\n                    userId: params.userId,\n                    bodyKeys: Object.keys(params.body),\n                });\n            } catch (error) {\n                elizaLogger.error(\"Failed to create log entry:\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    type: params.type,\n                    roomId: params.roomId,\n                    userId: params.userId,\n                });\n                throw error;\n            }\n        }, \"log\");\n    }\n\n    async searchMemoriesByEmbedding(\n        embedding: number[],\n        params: {\n            match_threshold?: number;\n            count?: number;\n            agentId?: UUID;\n            roomId?: UUID;\n            unique?: boolean;\n            tableName: string;\n        }\n    ): Promise<Memory[]> {\n        return this.withDatabase(async () => {\n            elizaLogger.debug(\"Incoming vector:\", {\n                length: embedding.length,\n                sample: embedding.slice(0, 5),\n                isArray: Array.isArray(embedding),\n                allNumbers: embedding.every((n) => typeof n === \"number\"),\n            });\n\n            // Validate embedding dimension\n            if (embedding.length !== getEmbeddingConfig().dimensions) {\n                throw new Error(\n                    `Invalid embedding dimension: expected ${getEmbeddingConfig().dimensions}, got ${embedding.length}`\n                );\n            }\n\n            // Ensure vector is properly formatted\n            const cleanVector = embedding.map((n) => {\n                if (!Number.isFinite(n)) return 0;\n                // Limit precision to avoid floating point issues\n                return Number(n.toFixed(6));\n            });\n\n            // Format for Postgres pgvector\n            const vectorStr = `[${cleanVector.join(\",\")}]`;\n\n            elizaLogger.debug(\"Vector debug:\", {\n                originalLength: embedding.length,\n                cleanLength: cleanVector.length,\n                sampleStr: vectorStr.slice(0, 100),\n            });\n\n            let sql = `\n                SELECT *,\n                1 - (embedding <-> $1::vector(${getEmbeddingConfig().dimensions})) as similarity\n                FROM memories\n                WHERE type = $2\n            `;\n\n            const values: any[] = [vectorStr, params.tableName];\n\n            // Log the query for debugging\n            elizaLogger.debug(\"Query debug:\", {\n                sql: sql.slice(0, 200),\n                paramTypes: values.map((v) => typeof v),\n                vectorStrLength: vectorStr.length,\n            });\n\n            let paramCount = 2;\n\n            if (params.unique) {\n                sql += ` AND \"unique\" = true`;\n            }\n\n            if (params.agentId) {\n                paramCount++;\n                sql += ` AND \"agentId\" = $${paramCount}`;\n                values.push(params.agentId);\n            }\n\n            if (params.roomId) {\n                paramCount++;\n                sql += ` AND \"roomId\" = $${paramCount}::uuid`;\n                values.push(params.roomId);\n            }\n\n            if (params.match_threshold) {\n                paramCount++;\n                sql += ` AND 1 - (embedding <-> $1::vector) >= $${paramCount}`;\n                values.push(params.match_threshold);\n            }\n\n            sql += ` ORDER BY embedding <-> $1::vector`;\n\n            if (params.count) {\n                paramCount++;\n                sql += ` LIMIT $${paramCount}`;\n                values.push(params.count);\n            }\n\n            const { rows } = await this.pool.query(sql, values);\n            return rows.map((row) => ({\n                ...row,\n                content:\n                    typeof row.content === \"string\"\n                        ? JSON.parse(row.content)\n                        : row.content,\n                similarity: row.similarity,\n            }));\n        }, \"searchMemoriesByEmbedding\");\n    }\n\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                await this.pool.query(\n                    `INSERT INTO participants (id, \"userId\", \"roomId\")\n                    VALUES ($1, $2, $3)`,\n                    [v4(), userId, roomId]\n                );\n                return true;\n            } catch (error) {\n                console.log(\"Error adding participant\", error);\n                return false;\n            }\n        }, \"addParticpant\");\n    }\n\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                await this.pool.query(\n                    `DELETE FROM participants WHERE \"userId\" = $1 AND \"roomId\" = $2`,\n                    [userId, roomId]\n                );\n                return true;\n            } catch (error) {\n                console.log(\"Error removing participant\", error);\n                return false;\n            }\n        }, \"removeParticipant\");\n    }\n\n    async updateGoalStatus(params: {\n        goalId: UUID;\n        status: GoalStatus;\n    }): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.pool.query(\n                \"UPDATE goals SET status = $1 WHERE id = $2\",\n                [params.status, params.goalId]\n            );\n        }, \"updateGoalStatus\");\n    }\n\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.pool.query(\n                \"DELETE FROM memories WHERE type = $1 AND id = $2\",\n                [tableName, memoryId]\n            );\n        }, \"removeMemory\");\n    }\n\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.pool.query(\n                `DELETE FROM memories WHERE type = $1 AND \"roomId\" = $2`,\n                [tableName, roomId]\n            );\n        }, \"removeAllMemories\");\n    }\n\n    async countMemories(\n        roomId: UUID,\n        unique = true,\n        tableName = \"\"\n    ): Promise<number> {\n        if (!tableName) throw new Error(\"tableName is required\");\n\n        return this.withDatabase(async () => {\n            let sql = `SELECT COUNT(*) as count FROM memories WHERE type = $1 AND \"roomId\" = $2`;\n            if (unique) {\n                sql += ` AND \"unique\" = true`;\n            }\n\n            const { rows } = await this.pool.query(sql, [tableName, roomId]);\n            return parseInt(rows[0].count);\n        }, \"countMemories\");\n    }\n\n    async removeAllGoals(roomId: UUID): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.pool.query(`DELETE FROM goals WHERE \"roomId\" = $1`, [\n                roomId,\n            ]);\n        }, \"removeAllGoals\");\n    }\n\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.pool.query(\n                `SELECT \"roomId\" FROM participants WHERE \"userId\" = $1`,\n                [userId]\n            );\n            return rows.map((row) => row.roomId);\n        }, \"getRoomsForParticipant\");\n    }\n\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\n        return this.withDatabase(async () => {\n            const placeholders = userIds.map((_, i) => `$${i + 1}`).join(\", \");\n            const { rows } = await this.pool.query(\n                `SELECT DISTINCT \"roomId\" FROM participants WHERE \"userId\" IN (${placeholders})`,\n                userIds\n            );\n            return rows.map((row) => row.roomId);\n        }, \"getRoomsForParticipants\");\n    }\n\n    async getActorDetails(params: { roomId: string }): Promise<Actor[]> {\n        if (!params.roomId) {\n            throw new Error(\"roomId is required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const sql = `\n                    SELECT\n                        a.id,\n                        a.name,\n                        a.username,\n                        a.\"avatarUrl\",\n                        COALESCE(a.details::jsonb, '{}'::jsonb) as details\n                    FROM participants p\n                    LEFT JOIN accounts a ON p.\"userId\" = a.id\n                    WHERE p.\"roomId\" = $1\n                    ORDER BY a.name\n                `;\n\n                const result = await this.pool.query<Actor>(sql, [\n                    params.roomId,\n                ]);\n\n                elizaLogger.debug(\"Retrieved actor details:\", {\n                    roomId: params.roomId,\n                    actorCount: result.rows.length,\n                });\n\n                return result.rows.map((row) => {\n                    try {\n                        return {\n                            ...row,\n                            details:\n                                typeof row.details === \"string\"\n                                    ? JSON.parse(row.details)\n                                    : row.details,\n                        };\n                    } catch (parseError) {\n                        elizaLogger.warn(\"Failed to parse actor details:\", {\n                            actorId: row.id,\n                            error:\n                                parseError instanceof Error\n                                    ? parseError.message\n                                    : String(parseError),\n                        });\n                        return {\n                            ...row,\n                            details: {}, // Fallback to empty object if parsing fails\n                        };\n                    }\n                });\n            } catch (error) {\n                elizaLogger.error(\"Failed to fetch actor details:\", {\n                    roomId: params.roomId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw new Error(\n                    `Failed to fetch actor details: ${error instanceof Error ? error.message : String(error)}`\n                );\n            }\n        }, \"getActorDetails\");\n    }\n\n    async getCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<string | undefined> {\n        return this.withDatabase(async () => {\n            try {\n                const sql = `SELECT \"value\"::TEXT FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`;\n                const { rows } = await this.query<{ value: string }>(sql, [\n                    params.key,\n                    params.agentId,\n                ]);\n                return rows[0]?.value ?? undefined;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching cache\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    key: params.key,\n                    agentId: params.agentId,\n                });\n                return undefined;\n            }\n        }, \"getCache\");\n    }\n\n    async setCache(params: {\n        key: string;\n        agentId: UUID;\n        value: string;\n    }): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                const client = await this.pool.connect();\n                try {\n                    await client.query(\"BEGIN\");\n                    await client.query(\n                        `INSERT INTO cache (\"key\", \"agentId\", \"value\", \"createdAt\")\n                         VALUES ($1, $2, $3, CURRENT_TIMESTAMP)\n                         ON CONFLICT (\"key\", \"agentId\")\n                         DO UPDATE SET \"value\" = EXCLUDED.value, \"createdAt\" = CURRENT_TIMESTAMP`,\n                        [params.key, params.agentId, params.value]\n                    );\n                    await client.query(\"COMMIT\");\n                    return true;\n                } catch (error) {\n                    await client.query(\"ROLLBACK\");\n                    elizaLogger.error(\"Error setting cache\", {\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                        key: params.key,\n                        agentId: params.agentId,\n                    });\n                    return false;\n                } finally {\n                    if (client) client.release();\n                }\n            } catch (error) {\n                elizaLogger.error(\n                    \"Database connection error in setCache\",\n                    error\n                );\n                return false;\n            }\n        }, \"setCache\");\n    }\n\n    async deleteCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                const client = await this.pool.connect();\n                try {\n                    await client.query(\"BEGIN\");\n                    await client.query(\n                        `DELETE FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`,\n                        [params.key, params.agentId]\n                    );\n                    await client.query(\"COMMIT\");\n                    return true;\n                } catch (error) {\n                    await client.query(\"ROLLBACK\");\n                    elizaLogger.error(\"Error deleting cache\", {\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                        key: params.key,\n                        agentId: params.agentId,\n                    });\n                    return false;\n                } finally {\n                    client.release();\n                }\n            } catch (error) {\n                elizaLogger.error(\n                    \"Database connection error in deleteCache\",\n                    error\n                );\n                return false;\n            }\n        }, \"deleteCache\");\n    }\n}\n\nexport default PostgresDatabaseAdapter;\n"],"mappings":"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","names":[]}